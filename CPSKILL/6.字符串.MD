# 字符串

# 目录
- [字符串](#字符串)
- [目录](#目录)
- [题目](#题目)
    - [找出数字](#找出数字)
    - [删除字符](#删除字符)
    - [字符串左中右](#字符串左中右)
    - [字符串替换](#字符串替换)
    - [分离单词](#分离单词)
    - [字符串逆序](#字符串逆序)
    - [Music Composer](#MusicComposer)
    - [Coin Test](#CoinTest)
    - [字符串排序](#字符串排序)
    - [字符串比较](#字符串比较)
# 题目

## 找出数字
```C
#include <stdio.h>

const int length = 1000; // 定义数组长度

// 返回str中数字的个数，并将数字写入arr
int string_to_int(char *str, int * arr) {
    int temp = 0;
    int count = 0; // 定义数字个数
    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] >= '0' && str[i] <= '9') {
            temp = (str[i] - '0') + temp * 10;
            if (str[i + 1] == '\0' || str[i + 1] < '0' || str[i + 1] > '9') {
                arr[count] = temp;
                count++;
                temp = 0;
            }
        }
    }
    return count;
}

int main() {
    int arr[length];
    char str[length];
    gets(str);
    int count = string_to_int(str, arr);
    printf("%d\n", count);
    for (int i = 0; i < count; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
```

## 删除字符
```C
#include <stdio.h>

const int length = 100;

void delete_char(char *s, char c) {
    int index = 0; // 用来指示原始数组的下标
    int count = 0; // 用来指示删除字符c后的下标
    while (s[index] != '\0') {
        if (s[index] != c) {
            s[count] = s[index];
            count++;
        }
        index++;
    }
    s[count] = '\0'; // 重置数组长度
}

int main() {
    char s[length];
    char c;
    gets(s);
    scanf("%c", &c);
    delete_char(s, c);
    printf("%s\n", s);
    return 0;
}
```

## 字符串左中右

```C
#include <stdio.h>

void left(char *src, int n, char *dest) {
    int i;
    for (i = 0; i < n; i++) {
        dest[i] = src[i];
    }
    dest[i] = '\0';
    return;
}

void mid(char *src, int local, int n, char *dest) {
    int i;
    for (i = 0; i < n; i++) {
        dest[i] = src[local + i];
    }
    dest[i] = '\0';
    return;
}

void right(char *src, int n, char *dest) {
    int length = 0;
    while (src[length++] != '\0');
    
    int local = length - n - 1;
    int i;
    for (i = 0; i < n; i++) {
            dest[i] = src[local + i];
    }
    dest[i] = '\0';
    return;
}


int main() {
    char src[1000], dest[1000];
    int n, local;
    scanf("%s", src);
    scanf("%d %d", &n, &local);

    left(src, n, dest);
    printf("%s\n", dest);
    right(src, n, dest);
    printf("%s\n", dest);
    mid(src, local, n, dest);
    printf("%s\n", dest);

    return 0;
}
```
## 字符串替换
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char * replace(char *src, char *oldstr, char *newstr) {
    char buffer_str[strlen(src)]; // 设置缓冲字符串
    memset(buffer_str, 0, sizeof(buffer_str)); // 初始化缓冲字符串

    // 在字符串src中查找是否存oldstr, 如果存在将新字符串复制到缓冲字符串，否则只将当前字符复制到缓冲字符串
    for (int i = 0; i < strlen(src); i++) {
        if (!strncmp(src + i, oldstr, strlen(oldstr))) {
            strcat(buffer_str, newstr);
            i += strlen(oldstr) - 1;
        } else {
            strncat(buffer_str, src + i, 1);
        }
    }
    
    strcpy(src, buffer_str);
    return src;
}

int main() {
    char str[1000];
    gets(str);
    replace(str, "you", "we");
    printf("%s\n", str);
    return 0;
}
```

## 分离单词
```C
#include <stdio.h>

const int MAX = 100;

const int LENGTH = 50;

int split(char *src, char (*dest)[LENGTH]) {
    int count = 0; // 计算分离出单词的数量
    int index = 0; // 在源字符串中的索引
    int is_word = 0; // 判断在该字符之前字符能否组成单词
    int is_split = 0; // 判断是否分割
    int j = 0; // 分离出的单词的临时长度
    for (; src[index] != '\0'; index++) {
        // 遇到分割符，应当进行分割， 要考虑连续多个都是分割符的情况
        if (src[index] == ' ' || src[index] == '.' || src[index] == ',') {
            is_split = 1; 
        }
        // 如果是字母，则表示可以组成单词
        if ((src[index] >= 'A' && src[index] <= 'Z') || (src[index] >= 'a' && src[index] <= 'z')) {
            is_word = 1;
            dest[count][j++] = src[index];
        }
        // 如果是连续的分割符但不是字母，不能组成单词
        if (is_split == 1 && is_word == 0) {
            is_split = 0;
            is_word = 0;
        }
        // 当为单词开头且到分割符或者是结束符的时候，分割单词
        if ((is_split == 1 || src[index + 1] == '\0') && is_word == 1) {
            dest[count][j] = '\0';
            count++;
            j = 0;
            is_word = 0;
            is_split = 0;
        }
    }
    return count;
}

int main() {
    char src[5000] = {'\0'};
    char dest[MAX][LENGTH] = {"\0"};
    gets(src);
    int count = split(src, dest);
    int i = count - 1;
    for (; i >= 0; i--) {
        printf("%s ", dest[i]);
    }
    return 0;
}
```

## 字符串逆序
```C
#include <stdio.h>

// 反转字符串
void reverse(char *str) {
    int length = 0;
    while (str[length++] != '\0');
    length -= 1;
    int left = 0;
    int right = length - 1;
    while (left < right) {
        char temp = str[left];
        str[left] = str[right];
        str[right] = temp;

        left++;
        right--;
    }
}

int main() {
    char str[1000];
    gets(str);
    int i = 0;
    while (str[i++] != '=');
    str[i - 1] = '\0';

    reverse(str);
    printf("%s\n", str);

    return 0;
}
```

## Music Composer
```C
#include <stdio.h>

int main() {
    char note[1024];
    while (gets(note) != NULL) {
        // 先将UNIQUE的进行判断
        if ((note[0] == 'A' || note[0] == 'B' || note[0] == 'C' || note[0] == 'D' || note[0] == 'E' || note[0] == 'F' || note[0] == 'G') && note[1] == ' ') {
            printf("UNIQUE\n");
        } else if (note[0] == 'A' && note[1] == '#') {
            note[0] = 'B';
            note[1] = 'b';
            printf("%s\n", note);
        } else if (note[0] == 'B' && note[1] == 'b') {
            note[0] = 'A';
            note[1] = '#';
            printf("%s\n", note);
        } else if (note[0] == 'C' && note[1] == '#') {
            note[0] = 'D';
            note[1] = 'b';
            printf("%s\n", note);
        } else if (note[0] == 'D' && note[1] == 'b') {
            note[0] = 'C';
            note[1] = '#';
            printf("%s\n", note);
        } else if (note[0] == 'D' && note[1] == '#') {
            note[0] = 'E';
            note[1] = 'b';
            printf("%s\n", note);
        } else if (note[0] =='E' && note[1] == 'b') {
            note[0] = 'D';
            note[1] = '#';
            printf("%s\n", note);
        } else if (note[0] == 'F' && note[1] == '#') {
            note[0] = 'G';
            note[1] = 'b';
            printf("%s\n", note);
        } else if (note[0] == 'G' && note[1] == 'b') {
            note[0] = 'F';
            note[1] = '#';
            printf("%s\n", note);
        } else if (note[0] == 'G' && note[1] == '#') {
            note[0] = 'A';
            note[1] = 'b';
            printf("%s\n", note);
        } else if (note[0] == 'A' && note[1] == 'b') {
            note[0] = 'G';
            note[1] = '#';
            printf("%s\n", note);
        } else {
            printf("false\n");
        }
    }
    return 0;
}
```

## Coin Test
```C
#include <stdio.h>

const int MAX = 1024;

// 计算绝对值
double fabs(double result) {
    return result > 0 ? result : -1.0 * result;
}

// 求最大公因数，根据gcd(a, b) = gcd(b, a%b)
int gcd(int a, int b) {
    if (a % b == 0) return b;
    else return gcd(b, a % b);
}

int main() {
    char result[MAX];
    int right = 0, left = 0, stand = 0;
    
    scanf("%s", result);
    int index = 0;
    // 统计各个可能出现的次数
    for (; result[index] != '\0'; index++) {
        if (result[index] == 'U') {
            right++;
        } else if (result[index] == 'D') {
            left++;
        } else if (result[index] == 'S') {
            stand = 1;
        }
    }
    if (stand == 1) {
        printf("WA\n");
    } else {
        if (right + left != index) {
            return 0;
        } else {
            double err = fabs(1.0 * right / index - 0.5);
            if (err > 0.003) {
                printf("Fail\n");
            } else {
                int factor = gcd(right, index);
                printf("%d/%d\n", right / factor, index / factor);
            }
        }
    }
    return 0;
}
```

## 字符串排序
```C
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// 比较函数
int compare(const void* tmp1, const void* tmp2) {
    char * str1 = (char *) tmp1;
    char * str2 = (char *) tmp2;
    return strcmp(str1, str2);
}

int main() {
    char strs[10][50];
    for (int i = 0; i < 10; i++) {
        scanf("%s", strs[i]);
    }
    // 使用stdlib快速排序
    qsort(strs, 10, sizeof(strs[0]), compare);

    for (int i = 0; i < 10; i++) {
        printf("%s ", strs[i]);
    }
    printf("\n");
    return 0;
}
```

## 字符串比较
```C
#include <stdio.h>

int compare(char *str1, char *str2) {
    int index = 0;
    while (str1[index] != '\0' && str2[index] != '\0' && str1[index] == str2[index]) {
        index++;
    }

    return (int)(str1[index] - str2[index]);
}

int main() {
    char str1[100], str2[100];
    gets(str1);
    gets(str2);

    printf("%d\n", compare(str1, str2));

    return 0;
}
```


> 对于字符串要实现一个动态增加长度，通过最终输入来确定数组的长度(以换行符作为结束符)

```C
#include <stdio.h>
#include <stdlib.h>

const int basic = 4;

char* scan(char *str) {
    if (str == NULL) {
        str = malloc(basic * sizeof(char));
    }
    int length = basic;
    int index = 0;
    while (scanf("%c", (str + index)) != EOF) {
        index++;
        if (str[index - 1] == '\n') {
            break;
        }
        if (index >= length) {
            length = length << 1;
            str = realloc(str, length);
        }
    }
    str[index - 1] = '\0';
    return str;
}

int main() {
    char *str = malloc(basic * sizeof(char));
    str = scan(str);
    printf("%s", str);
    return 0;
}
```