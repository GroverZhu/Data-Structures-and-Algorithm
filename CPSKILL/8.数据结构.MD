# 数据结构

# 目录
- [数据结构](#数据结构)
- [目录](#目录)
- [题目](#题目)
    - [排序分析](#排序分析)
    - [插入链表节点](#插入链表节点)
    - [链表节点删除](#链表节点删除)
    - [链表动态增长或缩小](#链表动态增长或缩小)
    - [创建与遍历职工链表](#创建与遍历职工链表)
    - [精确乘幂](#精确乘幂)
    - [大数加法](#大数加法)
    - [大数乘法](#大数乘法)
    - [大数除法](#大数除法)
    - [火车站](#火车站)

# 题目



## 排序分析
```C
#include <stdio.h>

// 给定数组arr，对arr[begin]～arr[end]进行排序
int bubble_sort(int *arr, int begin, int end) {
    int times = 0; // 记录交换次数
    // 对于n个数，需要进行n - 1轮的冒泡
    for (int i = 0; i < end - begin + 1; i++) {
        // 对于每个数，需要进行 n - i - 1 次的比较，当前的数比较之后，就会确定下位置，后续不需要参与比较
        for (int j = begin; j < end - i; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                times++;
            }
        }
    }
    return times;
}

int main() {
    int length, begin, end;
    scanf("%d", &length);
    int arr[length];
    for (int i = 0; i < length; i++) {
        scanf("%d", &arr[i]);
    }

    int times = bubble_sort(arr, 0, length - 1);

    printf("%d\n", times);
    return 0;
}
```

## 插入链表节点
```C
# include <stdio.h>
# include <stdlib.h>

// 定义节点类型
typedef struct node {
    int number;
    struct node *next;
} Node;

// 创建头节点
Node* create() {
    Node *head = (Node*)malloc(sizeof(Node));
    head->number = -1;
    head->next = NULL;
    return head;
}

// 采用尾插法创建链表
void insert(Node *self, int val) {
    Node *node = (Node*)malloc(sizeof(Node));
    node->number = val;
    node->next = NULL;
    Node *temp = self;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = node;
}

void insert_in_order(Node *self, int val) {
    Node *node = (Node*)malloc(sizeof(Node));
    node->number = val;
    node->next = NULL;
    Node *temp = self->next;
    // 找到插入节点的位置
    while (temp != NULL && temp->next != NULL  && temp->next->number < val) {
        temp = temp->next;
    }
    node->next = temp->next;
    temp->next = node;
}

void print_list(Node *self) {
    Node *temp = self->next;
    while(temp != NULL) {
        printf("%d ", temp->number);
        temp = temp->next;
    }
}

int main() {
    int total = 0;
    scanf("%d", &total);
    int val = 0;
    Node *list = create();
    while (total-- != 0) {
        scanf("%d", &val);
        insert(list, val);
    }
    scanf("%d", &val);
    insert_in_order(list, val);
    print_list(list);
    return 0;
}
```

## 链表节点删除   
⚠️⚠️ 在CPSKILL下报Compiler Error
️
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int no;
    char name[12];
    int age;
} student;

typedef struct N{
    student *val;
    struct N *next;
} node;

node* create() {
    student *stu = malloc(sizeof(student));
    stu->no = -1;
    strcpy(stu->name, "\0");
    stu->age = -1;
    node *head = malloc(sizeof(node));
    head->val = stu;
    head->next = NULL;
    return head;
}

void insert(node *self, node *stu_node) {
    node *temp = self;
    while (temp-> next != NULL) {
        temp = temp->next;
    }
    temp->next = stu_node;
}

node* search(node *self, int no) {
    node *temp = self->next;
    while (temp != NULL && temp->val->no != no) {
        temp = temp->next;
    }
    return temp;
}

void delete(node *self, node *stu_node) {
    if (stu_node != NULL) {
        node *temp = self;
        while (temp != NULL && temp->next != stu_node) {
            temp = temp->next;
        }
        temp->next = stu_node->next;
        free(stu_node);
    }
}

void print_list(node *self) {
    node *temp = self->next;
    while (temp != NULL) {
        printf("%d ", temp->val->no);
        temp = temp->next;
    }
}

int main() {
    int no = 0;
    char name[12] = "\0";
    int age = 0;
    node *list = create();
    while (scanf("%d", &no) != EOF) {
        if (no == 0) break;
        scanf("%s %d", name, &age);
        student *stu = malloc(sizeof(student));
        stu->age = age;
        strcpy(stu->name, name);
        stu->no = no;
        node *stu_node = malloc(sizeof(node));
        stu_node->val = stu;
        stu_node->next = NULL;
        insert(list, stu_node);
    }
    int search_no;
    scanf("%d", &search_no);
    print_list(list);
    printf("\n");
    node *tmp = search(list, search_no);
    delete(list, tmp);
    print_list(list);
    return 0;
}
```

## 链表动态增长或缩小
⚠️⚠️ 在CPSKILL平台下报Complier Error
```C
# include <stdio.h>
# include <stdlib.h>

typedef struct node {
    int number;
    struct node *next;
} Node;

// 创建链表
Node* create() {
    Node *head = malloc(sizeof(Node));
    head->number = -1;
    head->next = NULL;
    return head;
}

// 尾插法创建链表
void insert(Node *self, int val) {
    Node *node = malloc(sizeof(Node));
    node->number = val;
    node->next = NULL;
    
    Node *temp = self;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = node;
}

// 查找val是否在链表中
Node* search(Node *self, int val) {
    Node *temp = self->next;
    while (temp != NULL && temp->number != val) {
        temp = temp->next;
    }
    return temp;
}

// 删除指定节点
void delete(Node *self, Node *val) {
    Node *preview = self;

    while (preview->next != val) {
        preview = preview->next;
    }

    preview->next = val->next;

    free(val);
    val = NULL;
}

// 打印链表
void print_list(Node *self) {
    Node *temp = self->next;
    while (temp != NULL) {
        printf("%d ", temp->number);
        temp = temp->next;
    }
}

// 删除链表中有重复的内容
void duplicate(Node *self){
    Node *current = self->next;
    int flag = 0;
    while (current != NULL && current->next != NULL) {
        Node *latter = current->next;
        flag = 0;
        while (latter != NULL) {
            if (current->number == latter->number) {
                // 有重复节点，需要删除掉自身，设置flag进行标记
                flag = 1;
                Node *tmp = latter;
                latter = latter->next;
                delete(self, tmp);
            } else {
                latter = latter->next;
            }
        }
        if (flag == 1) {
            Node *del = current;
            current = current->next;
            delete(self, del);
        } else {
            current = current->next;
        }
    }
    return;
}

// 释放链表空间
void free_list(Node *self) {
    Node *temp = self->next;
    while (temp != NULL) {
        temp = temp->next;
    }
    while (temp != self) {
        Node *preview = self;
        while (preview->next != temp) {
            preview = preview->next;
        }
        free(temp);
        temp = NULL;
        temp = preview;
    }
    free(self);
    self = NULL;
}

int main() {
    int num;
    scanf("%d", &num);
    Node *list = create();
    int val;
    while (num-- > 0) {
        scanf("%d", &val);
        insert(list, val);
    }
    
    duplicate(list);

    print_list(list);

    free(list);

    return 0;

}
```

## 创建与遍历职工链表
```C
# include <stdio.h>
# include <stdlib.h>

// 定义节点类型
typedef struct node {
    int number; // 节点的有效载荷
    struct node *next; // 保存下一个节点的位置
} Node;

// 创建带头节点的链表
Node* create() {
    Node *head = (Node *)malloc(sizeof(Node));
    head->number = -1;
    head->next = NULL;
    return head;
}

// 尾插法建立链表
void insert(Node *self, int val) {
    Node *node = (Node *)malloc(sizeof(Node));
    node->number = val;
    node->next = NULL;
    Node *temp = self;
    // 有头节点，第一个节点肯定不为空
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = node;
}

// 遍历链表
void print_list(Node *self) {
    Node *temp = self->next;
    while (temp != NULL) {
        printf("%d ", temp->number);
        temp = temp->next;
    }
}

int main() {
    int total = 0;
    scanf("%d", &total);
    Node *list = create();
    int val = 0;
    while (total-- != 0) {
        scanf("%d", &val);
        insert(list, val);
    }
    print_list(list);
    return 0;
}
```
## 精确乘幂
```C
```


## 大数加法
```C
```

## 大数乘法
```C
```

## 大数除法
```C
```


## 火车站
```C
```