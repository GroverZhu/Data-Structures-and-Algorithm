# 枚举

# 目录
- [枚举](#枚举)
- [目录](#目录)
- [题目](#题目)
    - [危险的组合](#危险的组合)
    - [解不等式](#解不等式)
    - [幸运数字7](#幸运数字7)
    - [最大乘积](#最大乘积)
    - [特殊整数](#特殊整数)
    - [粒子裂变](#粒子裂变)
    - [子序列的和](#子序列的和)
    - [1的传奇](#1的传奇)
    - [韩信点兵](#韩信点兵)
    - [分数化小数](#分数化小数)


# 题目

## 危险的组合

根据数学知识推出如下递推公式
$$f(n) =\begin{cases}
0, n=1\\
0, n=2\\
1, n=3\\
3, n=4\\
2*f(n-1) + 2^{n-4} - f(n-4), n>4
\end{cases}$$

前4项容易理解，最后一项的，当前$n-1$项满足条件后，第n项就可以随意放置，故可能行为$2*f(n-1)$，当前$n-1$项均不满足条件，则表明加入第n项后才可满足条件，则最后一项必定是铀，所以要使得条件满足，摆放的$n-1$个项目仅有两个铀在一起，其他的均为铀铅交替摆放，所以满足这个条件的个数为$n-4$个的摆放可能减去$f(n-4)$的摆放可能。

```C
#include <stdio.h>


int main() {
    const int length = 30;
    int results[length + 1];
    results[1] = 0;
    results[2] = 0;
    results[3] = 1;
    results[4] = 3;

    for (int i = 5; i <= length; i++) {
        results[i] = 2 * results[i - 1] + (1 << (i - 4)) - results[i - 4];
    }

    int index;
    scanf("%d", &index);
    printf("%d\n", results[index]);

    return 0;
}
```

## 解不等式

```C
#include <stdio.h>

int main() {
    int begin, end;
    scanf("%d %d", &begin, &end);
    
    int flag = 0; // 标识位
    
    double base = 0.0;
    double sum = 0.0;
    
    for (int i = 1; sum < end; i++) {
        base += 1.0 / i;
        sum += 1.0 / base;
        
        
        if (sum > begin) {
            flag++;
        }
        
        if (flag == 1) {
            printf("%d ", i);
        }
        
        if (sum > end) {
            printf("%d\n", i-1);
        }
    }
    return 0;
}
```
## 幸运数字7

```C
#include <stdio.h>

// 判断n是否与7相关
int seven_related(int n) {
    if (n % 7 == 0) return 1;
    while (n != 0) {
        int temp = n % 10;
        if (temp == 7) return 1;
        n = n / 10;
    }
    return 0;
}

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 7; i < n; i++) {
        if (seven_related(i)) {
            printf("%d ", i);
        }
    }
    printf("\n");

    return 0;
}
```

## 最大乘积

采用动态规划的思想，记录前$n - 1$项的最大乘积值与最小乘积值，分别记为$maxi[n], mini[n]$,则$$maxi[n] = max{array[n], maxi[n - 1] * array[n], mini[n - 1] * array[n]}$$   
$$mini[n] = min{array[n], mini[n - 1] * array[n], maxi[n - 1] * array[n]}$$
```C
#include <stdio.h>

int max(int a, int b) {
    return a > b ? a : b;
}

int min(int a, int b) {
    return a < b ? a : b;
}

int main() {
    int length;
    scanf("%d", &length);
    
    int array[length];

    for (int i = 0; i < length; i++) {
        scanf("%d", &array[i]);
    }

    int mini[length];
    int maxi[length];
    mini[0] = array[0];
    maxi[0] = array[0];
    int maximum = array[0];

    for (int i = 1; i < length; i++) {
        maxi[i] = max(max(array[i], mini[i - 1] * array[i]), maxi[i - 1] * array[i]);
        mini[i] = min(min(array[i], maxi[i - 1] * array[i]), mini[i - 1] * array[i]);
        if (maxi[i] > maximum) {
            maximum = maxi[i];
        }
    }

    printf("%d\n", maximum);

    return 0;
}
```
## 特殊整数

```C
#include <stdio.h>

// 采用快速幂求指数
int pow(int base, int exponent) {
    if (exponent == 0) return 1;
    int result = 1;
    while (exponent != 0) {
        if (exponent % 2 != 0) {
            result = result * base;
        }
        base *= base;
        exponent /= 2;
    }
    return result;
}

// 判断数n是否满足要求, 包含m但不能被n整除

int is_satisfy(int n, int m) {
    if (n == 0 || n % m == 0) return 0;
    while (n != 0) {
        int temp = n % 10;
        if (temp == m) return 1;
        n /= 10;
    }
    return 0;
}

int main() {
    int m, n, count, sum;
    count = 0;
    sum = 0;
    scanf("%d %d", &m, &n);

    int begin = pow(10, n - 1);
    int end = pow(10, n);

    for (int i = begin; i < end; i++) {
        if (is_satisfy(i, m) == 1) {
            count++;
            sum += i;
        }
    }

    printf("%d %d", count, sum);

    return 0;
    
}
```
## 粒子裂变

设$\alpha(t)$为$\alpha$粒子在$t$时刻的数量，$\beta(t)$为$\beta$粒子在$t$时刻的数量，根据裂变规则可得
$\alpha(t) = \begin{cases}
1, t = 0 \\
0, t = 1 \\
3, t = 2 \\
\beta(t - 1), t \geq 3
\end{cases}$

$\beta(t) = \begin{cases}
0, t = 0 \\
3, t = 1 \\
6, t = 2 \\
3\alpha(t - 1) + 2  \beta(t - 1), t \geq 3
\end{cases}$

所以在$t \geq 3$时，$\alpha(t) = \beta(t - 1)$,$\beta(t) = 3\beta(t-2)+2\beta(t - 1)$
```C
#include <stdio.h>

int main() {
    int alpha = 0, beta = 0;
    int time = 0;
    scanf("%d", &time);
    if (time == 0) {
        alpha = 1;
        beta = 0;
    } else if (time == 1) {
        alpha = 0;
        beta = 3;
    } else if (time == 2) {
        alpha = 3;
        beta = 6;
    } else {
        int prior = 6;
        int first_two = 3;
        while ((time - 3) != -1) {
            beta = 3 * first_two + 2 * prior;
            first_two = prior;
            prior = beta;
            time--;
        }
        alpha = first_two;
    }

    printf("%d %d\n", alpha, beta);

    return 0;
}
```
## 子序列的和

```C
#include <stdio.h>

int main() {
    int n, m;
    double sum = 0.0;
    scanf("%d %d", &n, &m);
    for (int i = n; i <= m; i++) {
        double base = 1.0 / (i * 1.0) / (i * 1.0);
        sum += base;
    }

    printf("%.5lf\n", sum);

    return 0;
}
```
## 1的传奇

```C
#include <stdio.h>

// 计算1～num中含有x的个数
int count(int num, int x) {
    int times = 0;
    int temp = num;
    int base = 1;
    int high;

    // 从高位开始计算
    while (temp != 0) {
        high = temp / 10;
        // 最高不能为0
        if (x == 0) {
            if (high != 0) {
                high--;
            } else {
                break;
            }
        }

        times += high * base;

        int current = temp % 10;

        if (current > x) {
            times += base;
        } else if (current == x) {
            times += num - temp * base + 1;
        }

        base *= 10;
        temp = num / base;
    }

    return times;
}

int main() {
    int num;
    scanf("%d", &num);
    printf("%d\n", count(num, 1));
    return 0;
}
```
## 韩信点兵

```C
#include <stdio.h>

int main() {
    int a, b, c;
    scanf("%d %d %d", &a, &b, &c);
    int min = 10;
    int max = 100;
    int i;
    for (i = min; i <= max; i++) {
        if (i % 3 == a && i % 5 == b && i % 7 == c) {
            printf("%d\n", i);
            break;
        }
    }
    if (i > max) {
        printf("-1\n");
    }

    return 0;
}
```

## 分数化小数
```C
#include <stdio.h>

int main() {
    int a, b, digits;
    scanf("%d %d %d", &a, &b, &digits);
    // 多保留一位进行进位
    int num[digits + 2];

    num[0] = a / b;
    a = a % b;
    for (int i = 1; i <= digits + 1; i++) {
        num[i] = (a * 10) / b;
        a = (a * 10) % b;
    }

    // 进行四舍五入处理
    if (num[digits + 1] >= 5) {
        num[digits] += 1;
        for (int i = digits; i >= 1; i--) {
            if (num[i] == 10) {
                num[i] = 0;
                num[i - 1] += 1;
            }
        }
    }

    // 输出结果
    printf("%d.", num[0]);
    for (int i = 1; i <= digits; i++) {
        printf("%d", num[i]);
    }
    printf("\n");

    return 0;

}
```