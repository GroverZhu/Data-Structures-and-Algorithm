# 复杂数据

# 目录
- [复杂数据](#复杂数据)
- [目录](#目录)
- [题目](#题目)
   - [成绩表计算](#成绩表计算)
   - [文件比较](#文件比较)
   - [复数](#复数)
   - [检查图像文件格式](#检查图像文件格式)
   - [检测位图长宽](#检测位图长宽)
   - [字符串加密编码](#字符串加密编码)
   - [源程序添加行号](#源程序添加行号)
   - [重组字符串](#重组字符串)
   - [POJer的烦恼](#POJer的烦恼)
   - [插入字符](#插入字符)

# 题目

## 成绩表计算
```C
#include <stdio.h>

struct student {
    long no; // 学号
    char name[100]; // 姓名
    int age; // 年龄
    double en_score; // 英语
    double math_score; // 数学
    double zh_score; // 语文
    double politics_score; // 政治
    double physics_score; // 物理
    double chem_score; // 化学
    double computer_score; // 计算机
    double sum;
    double average;
};

int main() {
    struct student std[10];
    int index = 0;
    double sum = 0.0;
    for (int i = 0; i < 10; i++) {
        scanf("%ld %s %d %lf %lf %lf %lf %lf %lf %lf",
            &(std[i].no), std[i].name, &(std[i].age),
            &(std[i].en_score), &(std[i].math_score), &(std[i].zh_score),
            &(std[i].politics_score), &(std[i].physics_score), &(std[i].chem_score),
            &(std[i].computer_score));
        std[i].sum = std[i].en_score + std[i].math_score + std[i].zh_score + std[i].politics_score +
                     std[i].physics_score + std[i].chem_score + std[i].computer_score;
        std[i].average = std[i].sum / 7.0;
        if (sum < std[i].sum) {
            sum = std[i].sum;
            index = i;
        }
    }

    printf("%ld %s %d %.2lf %.2lf %.2lf %.2lf %.2lf %.2lf %.2lf\n",
    std[index].no, std[index].name, std[index].age,
    std[index].en_score, std[index].math_score, std[index].zh_score,
    std[index].politics_score, std[index].physics_score, std[index].chem_score,
    std[index].computer_score); 
}
```

## 文件比较
```C
#include <stdio.h>

const int MAX_LINE = 1024; // 设置一行最大的读取数

int main() {
    FILE *src, *dst;
    char src_line[MAX_LINE], dst_line[MAX_LINE];
    int line = 0; // 记录当前行数
    int index = 0; // 记录当前列数

    // 打开文件
    src = fopen("DATA5613.TXT", "r");
    dst = fopen("DATA5613.CPP", "r");

    if (src != NULL && dst != NULL) {
        while (fgets(src_line, MAX_LINE, src) != NULL && fgets(dst_line, MAX_LINE, dst) != NULL) {
            line++; // 题目要求是从1开始计算行数
            // 从两个文件中读取的字符串进行比较
            while (src_line[index] != '\0' && dst_line[index] != '\0') {
                // 不相等则输出对应的行数与列数
                if (src_line[index] != dst_line[index]) {
                    printf("%d %d\n", line, index + 1);
                }
                index++;
            }
            index = 0; // 重置列数
        }
        // 关闭文件
        fclose(src);
        fclose(dst);
    }
    return 0;
}
```

## 复数
```C
#include <stdio.h>
#include <stdlib.h>

typedef struct complex {
    double real; // 实部
    double image; // 虚部 
} Complex;

Complex add(Complex *self, Complex *other) {
    Complex result;
    result.real = self->real + other->real;
    result.image = self->image + other->image;
    return result;
}

Complex minus(Complex *self, Complex *other) {
    Complex result;
    result.real = self->real - other->real;
    result.image = self->image - other->image;
    return result;
}

Complex multiply(Complex *self, Complex *other) {
    Complex result;
    result.real = self->real * other->real - self->image * other->image;
    result.image = self->real * other->image + self->image * other->real;
    return result;
}

Complex divide(Complex *self, Complex *other) {
    double denominator = other->real * other->real + other->image * other->image;
    Complex other_reflect;
    other_reflect.real = other->real;
    other_reflect.image = -1.0 * other->image;
    Complex result;
    result = multiply(self, &other_reflect);
    result.real /= denominator;
    result.image /= denominator;
    return result;
}

int main() {
    Complex a, b;
    scanf("%lf %lf", &a.real, &a.image);
    scanf("%lf %lf", &b.real, &b.image);
    Complex add_result = add(&a, &b);
    Complex minus_result = minus(&a, &b);
    Complex multiply_result = multiply(&a, &b);
    Complex divide_result = divide(&a, &b);
    printf("(%.2lf%+.2lfi)+(%.2lf%+.2lfi)=(%.2lf%+.2lfi)\n", a.real, a.image, b.real, b.image, add_result.real, add_result.image);
    printf("(%.2lf%+.2lfi)-(%.2lf%+.2lfi)=(%.2lf%+.2lfi)\n", a.real, a.image, b.real, b.image, minus_result.real, minus_result.image);
    printf("(%.2lf%+.2lfi)*(%.2lf%+.2lfi)=(%.2lf%+.2lfi)\n", a.real, a.image, b.real, b.image, multiply_result.real, multiply_result.image);
    printf("(%.2lf%+.2lfi)/(%.2lf%+.2lfi)=(%.2lf%+.2lfi)\n", a.real, a.image, b.real, b.image, divide_result.real, divide_result.image);

    return 0;

}
```

> 函数传指针的写法在CPSKILL平台上会报Compile Error(🤔🤔🤔),本地llvm没问题
```C
#include <stdio.h>
#include <stdlib.h>

typedef struct complex {
    double real; // 实部
    double image; // 虚部 
} Complex;

Complex* add(Complex* self, Complex* other) {
    Complex *result = malloc(sizeof(Complex));
    result->real = self->real + other->real;
    result->image = self->image + other->image;
    return result;
}

Complex* minus(Complex *self, Complex *other) {
    Complex *result = malloc(sizeof(Complex));
    result->real = self->real - other->real;
    result->image = self->image - other->image;
    return result;
}

Complex* multiply(Complex *self, Complex *other) {
    Complex *result = malloc(sizeof(Complex));
    result->real = self->real * other->real - self->image * other->image;
    result->image = self->real * other->image + self->image * other->real;
    return result;
}

Complex* divide(Complex *self, Complex *other) {
    double denominator = other->real * other->real + other->image * other->image;
    Complex other_reflect;
    other_reflect.real = other->real;
    other_reflect.image = -1.0 * other->image;
    Complex *result = malloc(sizeof(Complex));
    result = multiply(self, &other_reflect);
    result->real /= denominator;
    result->image /= denominator;
    return result;
}

int main() {
    Complex a, b;
    scanf("%lf %lf", &a.real, &a.image);
    scanf("%lf %lf", &b.real, &b.image);
    Complex *_add = add(&a, &b);
    Complex *_minus = minus(&a, &b);
    Complex *_multiply = multiply(&a, &b);
    Complex *_divide = divide(&a, &b);
    printf("(%.2lf%+.2lfi)+(%.2lf%+.2lfi)=(%.2lf%+.2lfi)\n", a.real, a.image, b.real, b.image, _add->real, _add->image);
    printf("(%.2lf%+.2lfi)-(%.2lf%+.2lfi)=(%.2lf%+.2lfi)\n", a.real, a.image, b.real, b.image, _minus->real, _minus->image);
    printf("(%.2lf%+.2lfi)*(%.2lf%+.2lfi)=(%.2lf%+.2lfi)\n", a.real, a.image, b.real, b.image, _multiply->real, _multiply->image);
    printf("(%.2lf%+.2lfi)/(%.2lf%+.2lfi)=(%.2lf%+.2lfi)\n", a.real, a.image, b.real, b.image, _divide->real, _divide->image);

    free(_add);
    free(_minus);
    free(_multiply);
    free(_divide);
    
    return 0;

}
```

## 检查图像文件格式
```C
# include <stdio.h>
# include <string.h>

const char JPEG[] = "JFIF";
const char GIT[] = "GIF89a";
const char PNG[] = "PNG";

int main() {
    // 打开二进制文件
    FILE *pic = fopen("DATA5609.DAT", "rb");
    // 存储文件类型 JPEG => JFIF GIF => GIF89a PNG => PNG
    char jpeg_type[5] = "\0";
    char gif_type[7] = "\0";
    char png_type[4] = "\0";
    
    // 读取jpeg文件
    fseek(pic, 6, SEEK_SET); // 偏移文件指针
    fread(jpeg_type, sizeof(char), 4, pic); // 读取指定位置内容
    rewind(pic); // 重制指针为文件开始


    // 读取GIF文件
    fread(gif_type, sizeof(char), 6, pic);
    

    // 读取png文件
    fseek(pic, 1, SEEK_SET);
    fread(png_type, sizeof(char), 3, pic);
    rewind(pic);

    // 判断文件类型
    if (strcmp(jpeg_type, JPEG) == 0) {
        printf("JPEG\n");
    } else if (strcmp(gif_type, GIT) == 0) {
        printf("GIF\n");
    } else if (strcmp(png_type, PNG) == 0) {
        printf("PNG\n");
    } else {
        printf("NULL\n");
    }

    fclose(pic);
    return 0;
}
```


## 检测位图长宽
```C
#include <stdio.h>

// 设置字节对齐
#pragma pack(1)

// 位图文件头
struct bitmap_header {
   unsigned short bfType; // 标识
   unsigned int bfSize; // 文件大小
   unsigned short bfReserved1; // 保留字1
   unsigned short bfReserved2; // 保留字2
   unsigned int bfOffBits; // 偏移数 
};

// 位图信息头
struct bitmap_info {
    unsigned int biSize; // 位图信息头的大小
    long biWidth; // 位图的宽度， 单位为像素
    long biHeight; // 位图的高度， 单位为像素
    unsigned short biPlanes; // 固定值1
    unsigned short biBitCount; // 每个像素的位数
    unsigned int biCompression; // 压缩方式
    unsigned int biSizeImage; // 位图全部像素占用的字节数
    long biXPelsPerMeter; // 水平分辨率
    long biYPelsPerMeter; // 垂直分辨率
    unsigned int biClrUsed; // 位图使用的颜色数
    unsigned int biClrImportant; // 重要的颜色数
};

int main() {
    struct bitmap_header header;
    struct bitmap_info info;
    FILE *bmf;

    // 读取文件
    bmf = fopen("DATA5611.bmp", "rb");

    if (bmf != NULL) {
        fread(&header, sizeof(struct bitmap_header), 1, bmf);
        fread(&info, sizeof(struct bitmap_info), 1, bmf);
        printf("%ld %ld\n", info.biWidth, info.biHeight);
        fclose(bmf);
    }
    return 0;
}
```

## 字符串加密编码
```C
#include <stdio.h>

void encrypt(char *str) {
    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] >= 'A' && str[i] <= 'Z') {
            str[i] += 3;
        }
        if (str[i] >= 'a' && str[i] <= 'z') {
            str[i] -= 3;
        }
    }
    return;
}

int main() {
    char str[200];
    gets(str);
    encrypt(str);
    printf("%s\n", str);
    return 0;
}
```

## 源程序添加行号
```C
#include <stdio.h>

const int MAX = 1024; // 设置每行的最大数量

int main() {
    FILE *in; // 读入文件
    FILE *out; // 写入文件
    int line = 0;
    char in_line[MAX], out_line[MAX];

    // 读写的文件指针都不为空
    in = fopen("DATA5612.CPP", "r");
    out = fopen("DATA5612.TXT", "w");

    if (in != NULL && out != NULL) {
        // 读到读入文件的结尾
        while(fgets(in_line, MAX, in) != NULL) {
            sprintf(out_line, "%04d %s", ++line, in_line);
            fputs(out_line, out);
        }
        fclose(in);
        fclose(out);
    }
    return 0;
    
}
```

## 重组字符串
```C
#include <stdio.h>

void filters(char *str, char *dest) {
    int index = 0;
    for (int i = 0; str[i] != '\0'; i++) {
        if ((i % 2 == 1) && (str[i] % 2 == 1)) {
            dest[index] = str[i];
            index++; 
        }
    }
    dest[index] = '\0';
    return;
}

int main() {
    char str[81], dest[81];
    gets(str);
    filters(str, dest);
    printf("%s\n", dest);
    return 0;
}
```


## POJer的烦恼
```C
#include <stdio.h>
#include <memory.h>
const int length = 16;

/**
 * 将十进制num转化为二进制，并存在array数组中
 * 返回转为二进制数组的长度
 */
int transfer(int num, int *array) {
    int index = 0;
    while (num > 0) {
        *(array + index) = num % 2;
        num = num / 2;
        index++;
    }
    return index;
}

int main() {
    int arr[length];
    int num;
    scanf("%d", &num);
    memset(arr, 0, length * sizeof(arr[0]));
    int index = transfer(num, arr);
    for (int i = index - 1; i >= 0; i--) {
        printf("%d", arr[i]);
    }
    printf("\n");
    return 0;

}
```


## 插入字符
```C
#include <stdio.h>
#include <string.h>

void insert(char *str, int index, char c) {
    int length = (int)strlen(str);
    str[length + 1] = '\0';
    for (int i = length; i > index; i--) {
        str[i] = str[i - 1];
    }
    str[index] = c;
    return;
}

int main() {
    char str[81] = "";
    gets(str);
    int index;
    char c;
    scanf("%c %d", &c, &index);
    insert(str, index, c);
    printf("%s\n", str);
    return 0;
}
```