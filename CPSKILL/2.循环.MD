# 循环

# 目录

- [循环](#循环)
- [目录](#目录)
- [题目](#题目)
    - [完全数](#完全数)
    - [五猴分桃](#五猴分桃)
    - [区间内素数](#区间内素数)
    - [最次方数](#最次方数)
    - [你会存钱吗](#你会存钱吗)
    - [二分求根](#二分求根)
    - [计算$\pi$](#计算$\pi$)
    - [级数和](#级数和)
    - [多项式的猜想](#多项式的猜想)
    - [整数位数](#整数位数)

# 题目

## 完全数

```C
#include <stdio.h>

int main() {
    int max = 1000; 
    int factors[100]; // 记录每个数的因子
    int count = 0; // 记录因子的个数
    int temp = 0; // 将因子相加起来，记录一个数所有因子和

    // 开始遍历2～1000内的数字
    for (int i = 2; i <= max; i++) {
        // 记录每个数的因子
        for (int j = 1; j <= i / 2; j++) {
            if (i % j == 0) {
                factors[count] = j;
                count++;
                temp += j;
            }
        }

        // 验证并输出
        if (temp == i) {
            printf("%d=", i);
            for (int k = 0; k < count - 1; k++) {
                printf("%d+", factors[k]);
            }
            printf("%d\n", factors[count - 1]);
        }

        // 置0并进行下一个数的判断
        count = 0;
        temp = 0;
    }
}
```

## 五猴分桃

如果对于有n只猴子，每次第一次给的少了1个桃子，假设有$x$个桃子，如果刚好有$x+4$个桃子就够分了，所以第一个分完后有$\frac{4}{5}(x+4)$，则下一只猴子来分剩下的桃子后，剩下的桃子数为$(\frac{4}{5}) ^2(x+4)$, 所以有$n$只猴子来分的话，就会剩下$(\frac{4}{5} ^n)(x+4)$，所以要保证剩下的桃子的个数是整数，则$(x+4) = 5^n$， 可得$x = 5^n - 4$， 剩下的桃子为$(\frac{4}{5})^n(x+4) - 4$，减4是因为4是前面加上去的，所以带入得剩下的桃子个数为$4^n - 4$

```C
#include <stdio.h>

int main() {
    int monkey_num = 5;
    int peach_num = 1;
    int left_peach = 1;
    int temp = monkey_num;
    while (temp != 0) {
        peach_num = 5 * peach_num;
        temp--;
    }
    peach_num -= 4;

    temp = monkey_num;

    while (temp != 0) {
        left_peach = 4 * left_peach;
        temp--;
    }
    left_peach = left_peach - 4;

    printf("%d %d\n", peach_num, left_peach);

    return 0;

}
```


## 区间内素数
```C
#include <stdio.h>
#include <math.h>

/**
 * 判断n是否为素数，如果是返回1，不是返回0
 */
int is_prime(int n) {
    for (int i = 2; i <= sqrt(n); i++) {
        if (n % i == 0) {
            return 0;
        } else {
            continue;
        }
    }
    return 1;
}

int main() {
    int begin_interval = 500; // 开始区间
    int end_interval = 800; // 结束区间
    int prime[200]; // 保存素数
    int count = 0; // 确定素数个数

    // 寻找个数
    for (int i = begin_interval; i <= end_interval; i++) {
        if (is_prime(i)) {
            prime[count] = i;
            count++;
        }
    }

    // 计算和
    int interval_sum = 0;
    int flag = 1; // 标识位，记录符号
    for (int i = count - 1; i > -1; i--) {
        if (flag == 1) {
            interval_sum += prime[i];
            flag = 0;
        } else {
            interval_sum -= prime[i];
            flag = 1;
        }
    }

    printf("%d %d", count, interval_sum);

    return 0;

}
```

## 最次方数

```C
#include <stdio.h>

int main() {
    int base, index;
    scanf("%d %d", &base, &index);

    int result = 1;
    while (index != 0) {
        result = result * base % 1000;
        index--;
    }

    printf("%d\n", result);

    return 0;
}
```

## 你会存钱吗

```C
#include <stdio.h>

// 采用快速求幂法求base^exponent
double pow(double base, int exponent) {
    double result = 1.0;
    while (exponent != 0) {
        if (exponent % 2 != 0) {
            result *= base;
        }
        base *= base;
        exponent /= 2;
    }
    return result;
}



// 记录存钱年份的利率
const double one_interest = 0.0063 * 12 * 1;
const double two_interest = 0.0066 * 12 * 2;
const double three_interest = 0.0069 * 12 * 3;
const double five_interest = 0.0075 * 12 * 5;
const double eight_interest = 0.0084 * 12 * 8;
 
int main() {
    double capital = 2000.0; // 本金
    double capital_and_interest = 2000.0; // 本金加利息
    int years[5] = {0};
    int total_year = 20;

    for (int i = 0; i <= total_year / 8; i++) {
        for (int j = 0; j <= (total_year - i * 8) / 5; j++) {
            for (int k = 0; k <= (total_year - i * 8 -j * 5) / 3; k++) {
                for (int m = 0; m <= (total_year - i * 8 - j * 5 - k * 3) / 2; m++) {
                    int n = total_year - i * 8 - j * 5 - k * 3 - m * 2;
                    double temp = capital 
                                * pow(1.0 + one_interest, n)
                                * pow(1.0 + two_interest, m)
                                * pow(1.0 + three_interest, k)
                                * pow(1.0 + five_interest, j)
                                * pow(1.0 + eight_interest, i);                                ;
                    if (temp >= capital_and_interest) {
                        capital_and_interest = temp;
                        years[0] = i;
                        years[1] = j;
                        years[2] = k;
                        years[3] = m;
                        years[4] = n;
                    }
                }
            }
        }
    }

    for (int i = 0; i < 5; i++) {
        printf("%d ", years[i]);
    }
    printf("\n%.2f\n", capital_and_interest);
    return 0;

}
```

## 二分求根

```C
#include <stdio.h>

//  取绝对值
double fabs(double temp) {
    if (temp > 0) {
        return temp;
    } else {
        return -1.0 * temp;
    }
}

// 设置误差
const double delta = 1e-6;


// 计算方程的值
double function_result(double x) {
    return 2.0 * x * x * x - 4.0 * x * x + 3.0 * x - 6.0; 
}

int main() {
    double begin = -10;
    double end = 10;
    double mid = begin + (end - begin) / 2.0;

    double mid_result = function_result(mid);

    // 二分求解
    while (fabs(mid_result) > delta) {
        double begin_result = function_result(begin);
        if (begin_result * mid_result > 0) {
            begin = mid;
        } else {
            end = mid;
        }
        mid = begin + (end - begin) / 2.0;
        mid_result = function_result(mid);
    }

    printf("%.2lf\n", mid);

    return 0;
}

```

## 计算$\pi$

```C
#include <stdio.h>

int main() {
    double pi = 0.0;
    double count = 1.0;
    int flag = 1;

    while ((1.0 / count) > 1e-6) {
        if (flag == 1) {
            pi = pi +  1.0 / count;
            flag = 0;
            count += 2.0;
        } else {
            pi = pi - 1.0 / count;
            flag = 1;
            count += 2.0;
        }
    }

    printf("%.6lf", pi * 4.0);

    return 0;
}
```

## 级数和

```C
#include <stdio.h>

// 计算每一项的值
double caculate_element(int j) {
    int base = 1 << j; // 2的倍数可直接位移
    int append = 1;
    if (j % 2 != 0) {
        append = -1;
    }

    double result = (-1.0 * append * base) 
                    / (1.0 * (base + append)) 
                    / ((base << 1) + -1.0 * append);

    return result;
}

int main() {
    int n;
    scanf("%d", &n);

    double result = 0.0;
    while (n!= 0) {
        result += caculate_element(n);
        n--;
    }

    printf("%.6lf", result);

    return 0;
}
```

## 多项式的猜想

```C
#include <stdio.h>

const int length = 20;

// 返回值所在的数组索引
int get_index(int array[], int sum) {
    int temp_sum = 0;
    int i = 0;
    for (; i < length - 1; i++) {
        temp_sum += array[i];
        if (temp_sum < sum && temp_sum + array[i + 1] >= sum) {
            break;
        }
    }
    return i;
}

int main() {
    int a1 = 1, a2 = 1;
    int array[length];
    array[0] = 1;
    array[1] = 1;
    for (int i = 2; i < length; i++) {
        array[i] = array[i - 2] + 2 * array[i - 1];
    }

    printf("%d\n", get_index(array, 100) + 1);
    printf("%d\n", get_index(array, 1000) + 1);
    printf("%d\n", get_index(array, 10000) + 1);

    return 0;
}
```

## 整数位数

```C
#include <stdio.h>

int main() {
    double num;
    scanf("%lf", &num);
    if (num < 0) {
        num = -num;
    }
    int count = 0;
    while (num >= 1) {
        count++;
        num = num / 10.0;
    }

    printf("%d\n", count);

    return 0;
}
```