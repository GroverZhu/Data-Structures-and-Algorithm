[
{"number": "001", "name": "计算A+B", "description": ["计算A+B"], "image_urls": [], "input": "输入整数A和整数B的值，用空格隔开", "output": "输出A+B的结果", "sample_input": "1 2", "sample_output": "3"},
{"number": "035", "name": "积分计算", "description": ["已知", "编写函数用梯形法计算f(x)在区间[a,b]的积分"], "image_urls": ["poj/images/80/8000030002.jpg"], "input": "输入a和b，a＜b，均为double型", "output": "输出为double型", "sample_input": "0.5 1", "sample_output": "0.321751"},
{"number": "034", "name": "ACKERMAN", "description": ["已知ack函数对于m≥0和n≥0有定义：ack(0,n)=n+1、ack(m,0)=ack(m-1,1)、ack(m,n)=ack(m-1,ack(m,n-1))。输入m和n，求解ack函数。"], "image_urls": [], "input": "输入m和n，均为整型，用空格隔开。", "output": "输出为整型", "sample_input": "3 2", "sample_output": "29"},
{"number": "033", "name": "A+B II", "description": ["豆豆今年3岁了，现在他已经能够认识100以内的非负整数，并且能够进行100以内的非负整数的加法计算。对于大于等于100的整数，豆豆仅保留该数的最后两位进行计算，如果计算结果大于等于100，那么豆豆也仅保留计算结果的最后两位。", "例如, 对于小明来说：", "（1）1234和34是相等的", "（2）35+80=15", "给定非负整数A和B, 你的任务是代表豆豆计算出A+B的值。"], "image_urls": [], "input": "输入数据的第1行为一个正整数T，表示测试数据的组数，然后是T组测试数据。每组测试数据包含两个非负整数A和B（A和B均在int型可表示的范围内）。", "output": "对于每组测试数据, 输出豆豆A+B的结果。", "sample_input": "2\r35 80\r15 1152", "sample_output": "15\r67"},
{"number": "032", "name": "最小整数", "description": ["编写函数fceil(x)，返回大于等于x的最小整数，例如fceil(2.8)为3，fceil(-2.8)为-2。"], "image_urls": [], "input": "输入double型x。", "output": "输出整型。", "sample_input": "2.8", "sample_output": "3"},
{"number": "031", "name": "循环移位", "description": ["编写函数实现value左右循环移位（即移出的位在另一端填入）。函数原型为int move(int value,int n)；其中value为要循环移位的数，n为移位的位数，n的绝对值不大于16，整型为16位。如果n＜0表示左移，n＞0表示右移，n=0表示不移位。在主函数中输入数据并调用该函数输出结果。"], "image_urls": [], "input": "输入value和n，均为整型，用空格隔开", "output": null, "sample_input": "134744064 -8", "sample_output": "134742024"},
{"number": "030", "name": "分数化小数", "description": ["输入正整数a、b、c，输出a/b的小数形式，精确到小数点后c位。其中a、b≤1000000，c≤100。注意：本题有数据陷进。"], "image_urls": [], "input": "输入正整数a、b、c，用空格隔开", "output": "输出计算结果，小数点后c位", "sample_input": "1 6 4", "sample_output": "0.1667"},
{"number": "029", "name": "最大乘积", "description": ["输入n个元素组成的序列S，你需要找出一个乘积最大的连续子序列。如果这个最大的乘积不是正数，输出-1表示无解。1≤n≤18，-10≤Si≤10。"], "image_urls": [], "input": "第1行输入n，整数", "output": "输出最大乘积，若无解输出-1", "sample_input": "5\r2 5 -1 2 -1", "sample_output": "20"},
{"number": "028", "name": "幸运数字“7”", "description": ["输出7和7的倍数，还有包含7的数字例如（17，27，37...70，71，72，73...）"], "image_urls": [], "input": "一个整数N。(N不大于30000)", "output": "从小到大排列的不大于N的与7有关的数字，用空格隔开", "sample_input": "20", "sample_output": "7 14 17"},
{"number": "026", "name": "除法", "description": ["输入正整数n，按从小到大的顺序输出所有形如abcde/fghij=n的表达式，其中a～j恰好为数字0～9的一个排列，2≤n≤79。"], "image_urls": [], "input": "输入正整数n", "output": "输出形如abcde/fghij=n的表达式，每行一个", "sample_input": "62", "sample_output": "79546/01283=62\r94736/01528=62"},
{"number": "027", "name": "羊羊聚会", "description": ["青青草原上的美羊羊最近在网上相识了非洲部落的沸羊羊，它们聊得很开心，于是觉得有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西走，直到碰面为止。", "可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过羊羊们很乐观，它们觉得只要一直朝着某个方向走下去，总能碰到对方。但是除非这两只羊在同一时间走到同一点上，不然永远都不可能碰面。为了帮助这两只乐观的羊，你被要求写一个程序来判断这两只羊是否能够碰面，会在什么时候碰面。", "规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设美羊羊的出发点坐标是x，沸羊羊的出发点坐标是y。美羊羊一小时能走a米，沸羊羊一次能走b米。纬度线总长L米。求出它们走了多少小时以后才会碰面。"], "image_urls": [], "input": "输入一行5个整数x，y，a，b，L，其中x≠y ＜2000000000，0＜a、b＜2000000000，0＜L＜2100000000。", "output": "输出碰面所需要的跳跃次数，如果永远不可能碰面则输出impossible", "sample_input": "1 2 3 4 5", "sample_output": "4"},
{"number": "025", "name": "韩信点兵", "description": ["相传韩信才智过人，从不直接清点自己军队的人数，只要让士兵先后以三人一排、五人一排、七人一排地变换队形，而他每次只看一眼队伍的排尾就知道总人数了。输入3个非负整数a、b、c，表示每种队形排尾的人数（a＜3、b＜5、c＜7），输出总人数的最小值或报告无解。", "已知总人数不小于10，不超过100。"], "image_urls": [], "input": "输入非负整数a、b、c，用空格隔开", "output": "输出总人数，为整数，用空格隔开；若无解输出-1", "sample_input": "2 1 6", "sample_output": "41"},
{"number": "024", "name": "危险的组合", "description": ["有一些装有铀和铅的盒子，数量均足够多。要求把n（n≤30）个盒子放成一行，但至少有3个铀放在一起，问有多少种方法？"], "image_urls": [], "input": "输入整数n", "output": "输出放置方法的数目", "sample_input": "5", "sample_output": "8"},
{"number": "023", "name": "特殊整数", "description": ["设m，n为一位正整数，含有数字m且不能被m整除的n位整数的个数为g，这些整数和为s。计算g、s。"], "image_urls": [], "input": "输入m和n，均为一位正整数，用空格隔开", "output": "输出g、s，均为整数，用空格隔开", "sample_input": "7 5", "sample_output": "32152 1894711910"},
{"number": "022", "name": "探索合数世纪", "description": ["若一个世纪的100个年号中不存在一个素数，则这个世纪称为合数世纪。求第n个合数世纪（公元0年起始）。"], "image_urls": [], "input": "输入n，为整数", "output": "输出合数世纪起始与结束年份，用空格隔开", "sample_input": "1", "sample_output": "1671800 1671899"},
{"number": "021", "name": "粒子裂变", "description": ["核反应堆中有α和β两种粒子，每秒钟内一个α粒子可以裂变为3个β粒子，而一个β粒子可以裂变为1个α粒子和2个β粒子。若在t=0时刻的反应堆中只有一个α粒子，求在t秒时反应堆裂变产生的α粒子和β粒子数。"], "image_urls": [], "input": "输入t，为整型", "output": "输出在t秒时反应堆裂变产生的α粒子和β粒子数，为整型，用空格隔开", "sample_input": "6", "sample_output": "183 546"},
{"number": "100", "name": "Checksum algorithm", "description": ["A checksum is an algorithm that scans a packet of data and returns a single number. The idea is that if the packet is changed, the checksum will also change, so checksums are often used for detecting transmission errors, validating document contents, and in many other situations where it is necessary to detect undesirable changes in data.", "For this problem, you will implement a checksum algorithm called Quicksum. A Quicksum packet allows only uppercase letters and spaces. It always begins and ends with an uppercase letter. Otherwise, spaces and letters can occur in any combination, including consecutive spaces.", "A Quicksum is the sum of the products of each character's position in the packet times the character's value. A space has a value of zero, while letters have a value equal to their position in the alphabet. So, A=1, B=2, etc., through Z=26. Here are example Quicksum calculations for the packets \"ACM\" and \"MID CENTRAL\":", "ACM: 1*1  + 2*3 + 3*13 = 46", "MID CENTRAL: 1*13 + 2*9 + 3*4 + 4*0 + 5*3 + 6*5 + 7*14 + 8*20 + 9*18 + 10*1 + 11*12 = 650"], "image_urls": [], "input": "The input consists of one or more packets followed by a line containing only # that signals the end of the input. Each packet is on a line by itself, does not begin or end with a space, and contains from 1 to 255 characters.", "output": "For each packet, output its Quicksum on a separate line in the output.", "sample_input": "ACM\rMID CENTRAL\rREGIONAL PROGRAMMING CONTEST\rACN\rA C M\rABC\rBBC\r#", "sample_output": "46\r650\r4690\r49\r75\r14\r15"},
{"number": "099", "name": "Road trip", "description": ["Bill and Ted are taking a road trip. But the odometer in their car is broken, so they don't know how many miles they have driven. Fortunately, Bill has a working stopwatch, so they can record their speed and the total time they have driven. Unfortunately, their record keeping strategy is a little odd, so they need help computing the total distance driven. You are to write a program to do this computation.", "For example, if their log shows", "this means they drove 2 hours at 20 miles per hour, then 6-2=4 hours at 30 miles per hour, then 7-6=1 hour at 10 miles per hour. The distance driven is then (2)(20) + (4)(30) + (1)(10) = 40 + 120 + 10 = 170 miles. Note that the total elapsed time is always since the beginning of the trip, not since the previous entry in their log. "], "image_urls": ["poj/images/80/8000005007.jpg"], "input": "The input consists of one or more data sets. Each set starts with a line containing an integer n, 1 <= n <= 10, followed by n pairs of values, one pair per line. The first value in a pair, s, is the speed in miles per hour and the second value, t, is the total elapsed time. Both s and t are integers, 1 <= s <= 90 and 1 <= t <= 12. The values for t are always in strictly increasing order. A value of -1 for n signals the end of the input. ", "output": "For each input set, print the distance driven", "sample_input": "3\r20 2\r30 6\r10 7\r2\r60 1\r30 5\r-1", "sample_output": "170\r180"},
{"number": "098", "name": "Sticks", "description": ["George took sticks of the same length and cut them randomly until all parts became at most 50 units long. Now he wants to return sticks to the original state, but he forgot how many sticks he had originally and how long they were originally. Please help him and design a program which computes the smallest possible original length of those sticks. All lengths expressed in units are integers greater than zero. "], "image_urls": [], "input": "The input contains blocks of 2 lines. The first line contains the number of sticks parts after cutting, there are at most 64 sticks. The second line contains the lengths of those parts separated by the space. The last line of the file contains zero.", "output": "The output should contains the smallest possible length of original sticks, one per line. ", "sample_input": "9\r5 2 1 5 2 1 5 2 1\r4\r1 2 3 4\r0", "sample_output": "6\r5"},
{"number": "097", "name": "Specialized Numbers", "description": ["Find and list all four-digit numbers in decimal notation that have the property that the sum of its four digits equals the sum of its digits when represented in hexadecimal (base 16) notation and also equals the sum of its digits when represented in duodecimal (base 12) notation.", "For example, the number 2991 has the sum of (decimal) digits 2+9+9+1 = 21. Since 2991 = 1*1728 + 8*144 + 9*12 + 3, its duodecimal representation is 189312, and these digits also sum up to 21. But in hexadecimal 2991 is BAF16, and 11+10+15 = 36, so 2991 should be rejected by your program.", "The next number (2992), however, has digits that sum to 22 in all three representations (including BB016), so 2992 should be on the listed output. (We don't want decimal numbers with fewer than four digits -- excluding leading zeroes -- so that 2992 is the first correct answer.) "], "image_urls": [], "input": "There is no input for this problem", "output": "Your output is to be 2992 and all larger four-digit numbers that satisfy the requirements (in strictly increasing order), each on a separate line with no leading or trailing blanks, ending with a new-line character. There are to be no blank lines in the output. The first few lines of the output are shown below.", "sample_input": null, "sample_output": "2992\r2993\r2994\r…"},
{"number": "096", "name": "Sum of Consecutive", "description": ["Some positive integers can be represented by a sum of one or more consecutive prime numbers. How many such representations does a given positive integer have? For example, the integer 53 has two representations 5 + 7 + 11 + 13 + 17 and 53. The integer 41 has three representations 2+3+5+7+11+13, 11+13+17, and 41. The integer 3 has only one representation, which is 3. The integer 20 has no such representations. Note that summands must be consecutive prime", "numbers, so neither 7 + 13 nor 3 + 5 + 5 + 7 is a valid representation for the integer 20.", "Your mission is to write a program that reports the number of representations for the given positive integer."], "image_urls": [], "input": "The input is a sequence of positive integers each in a separate line. The integers are between 2 and 10 000, inclusive. The end of the input is indicated by a zero.", "output": "The output should be composed of lines each corresponding to an input line except the last zero. An output line includes the number of representations for the input integer as the sum of one or more consecutive prime numbers. No other characters should be inserted in the output.", "sample_input": "2\r17\r41\r20\r666\r0", "sample_output": "1\r2\r3\r0\r0"},
{"number": "094", "name": "Houseboat", "description": ["Fred Mapper is considering purchasing some land in Louisiana to build his house on. In the process of investigating the land, he learned that the state of Louisiana is actually shrinking by 50 square miles each year, due to erosion caused by the Mississippi River. Since Fred is hoping to live in this house the rest of his life, he needs to know if his land is going to be lost to erosion.", "After doing more research, Fred has learned that the land that is being lost forms a semicircle(Red). This semicircle is part of a circle centered at (0,0), with the line that bisects the circle being the X axis. Locations below the X axis are in the water(Blue). The semicircle has an area of 0 at the beginning of year 1. (Semicircle illustrated in the Figure.) "], "image_urls": ["poj/images/80/8000005002.jpg"], "input": "The first line of input will be a positive integer indicating how many data sets will be included (N). Each of the next N lines will contain the X and Y Cartesian coordinates of the land Fred is considering. These will be floating point numbers measured in miles. The Y coordinate will be non-negative. (0,0) will not be given.", "output": "For each data set, a single line of output should appear. This line should take the form of: “ N Z” Where N is the data set (counting from 1), and Z is the first year (start from 1) this property will be within the semicircle AT THE END OF YEAR Z. Z must be an integer. ", "sample_input": "2\r1.0 1.0\r25.0 0.0", "sample_output": "1 1\r2 20"},
{"number": "095", "name": "Graveyard", "description": ["Programming contests became so popular in the year 2397 that the governor of New Earck — the largest human-inhabited planet of the galaxy — opened a special Alley of Contestant Memories (ACM) at the local graveyard. The ACM encircles a green park, and holds the holographic statues of famous contestants placed equidistantly along the park perimeter. The alley has to be renewed from time to time when a new group of memorials arrives.", "When new memorials are added, the exact place for each can be selected arbitrarily along the ACM, but the equidistant disposition must be maintained by moving some of the old statues along the alley.", "Surprisingly, humans are still quite superstitious in 24th century: the graveyard keepers believe the holograms are holding dead people souls, and thus always try to renew the ACM with minimal possible movements of existing statues (besides, the holographic equipment is very heavy). Statues are moved along the park perimeter. Your work is to find a renewal plan which minimizes the sum of travel distances of all statues. Installation of a new hologram adds no distance penalty, so choose the places for newcomers wisely!"], "image_urls": [], "input": "Input file contains two integer numbers: n — the number of holographic statues initially located at the ACM, and m — the number of statues to be added (2 ≤ n ≤ 1000, 1 ≤ m ≤ 1000). The length of the alley along the park perimeter is exactly 10 000 feet.Te end of the input is indicated by 0 0.", "output": "Write a single real number to the output file — the minimal sum of travel distances of all statues (in feet). The answer must be precise to at least 4 digits after decimal point.", "sample_input": "2 1\r2 3\r0 0", "sample_output": "1666.6667\r1000.0000"},
{"number": "093", "name": "Double", "description": ["As part of an arithmetic competency program, your students will be given randomly generated lists of from 2 to 15 unique positive integers and asked to determine how many items in each list are twice some other item in the same list. You will need a program to help you with the grading. This program should be able to scan the lists and output the correct answer for each one. For example, given the list", "1 4 3 2 9 7 18 22", "your program should answer 3, as 2 is twice 1, 4 is twice 2, and 18 is twice 9."], "image_urls": [], "input": "There will be one list of numbers per line. Each list will contain from 2 to 15 unique positive integers. No integer will be larger than 99. Each line will be terminated with the integer 0, which is not considered part of the list.", "output": "The output contain a count of the items that are double some other item. ", "sample_input": "1 4 3 2 9 7 18 22 0", "sample_output": "3"},
{"number": "092", "name": "Bee", "description": ["In Africa there is a very special species of bee. Every year, the female bees of such species give birth to one male bee, while the male bees give birth to one male bee and one female bee, and then they die!", "Now scientists have accidentally found one \"magical female bee\" of such special species to the effect that she is immortal, but still able to give birth once a year as all the other female bees. The scientists would like to know how many bees there will be after N years. Please write a program that helps them find the number of male bees and the total number of all bees after N years."], "image_urls": [], "input": "Each line of input contains an integer N (≥ 0). Input ends with a case where N = -1. (This case should NOT be processed.) ", "output": "Each line of output should have two numbers, the first one being the number of male bees after N years, and the second one being the total number of bees after N years. (The two numbers will not exceed 2e+32.) ", "sample_input": "1\r3\r-1", "sample_output": "1 2\r4 7"},
{"number": "091", "name": "Scoring", "description": ["Judging a programming contest is hard work, with demanding contestants, tedious decisions,and monotonous work. Not to mention the nutritional problems of spending 12 hours with only donuts, pizza, and soda for food. Still, it can be a lot of fun.", "Software that automates the judging process is a great help, but the notorious unreliability of some contest software makes people wish that something better were available. You are part of a group trying to develop better, open source, contest management software, based on the principle of modular design.", "Your component is to be used for calculating the scores of programming contest teams and determining a winner. You will be given the results from several teams and must determine the winner.", "Scoring", "There are two components to a team's score. The first is the number of problems solved. The second is penalty points, which reflects the amount of time and incorrect submissions made before the problem is solved. For each problem solved correctly, penalty points are charged equal to the time at which the problem was solved plus 20 minutes for each incorrect submission. No penalty points are added for problems that are never solved.", "So if a team solved problem one on their second submission at twenty minutes, they are charged 40 penalty points. If they submit problem 2 three times, but do not solve it, they are charged no penalty points. If they submit problem 3 once and solve it at 120 minutes, they are charged 120 penalty points. Their total score is two problems solved with 160 penalty points.", "The winner is the team that solves the most problems. If teams tie for solving the most problems,then the winner is the team with the fewest penalty points."], "image_urls": [], "input": "For the programming contest your program is judging, there are four problems. You are guaranteed that the input will not result in a tie between teams after counting penalty points.", "output": "The output consists of a single line listing the name of the team that won, the number of problems they solved, and their penalty points.", "sample_input": "4\rStars 2 20 5 0 4 190 3 220\rRockets 5 180 1 0 2 0 3 100\rPenguins 1 15 3 120 1 300 4 0\rMarsupials 9 0 3 100 2 220 3 80", "sample_output": "Penguins 3 475"},
{"number": "090", "name": "操场训练", "description": ["在一个划分成网格的操场上，n个士兵散乱地站在网格点上。网格点由整数坐标(x,y)表示。士兵们可以沿网格边上、下、左、右移动一步，但在同一时刻任一网格点上只能有一名士兵。按照军官的命令，士兵们要整齐地列成一个水平队列，即排列成(x,y),(x+1,y),…,(x+n-1,y)。如何选择x 和y的值才能使士兵们以最少的总移动步数排成一列。", "计算使所有士兵排成一行需要的最少移动步数。"], "image_urls": [], "input": "第1行输入士兵数n，1≤n≤10000。接下来n行是士兵的初始位置，每行2个整数x和y，-10000≤x，y≤10000。", "output": "输出士兵排成一行需要的最少移动步数。", "sample_input": "5\r1 2\r2 2\r1 3\r3 -2\r3 3", "sample_output": "8"},
{"number": "089", "name": "寻找规律", "description": ["小鹏在小学时最喜欢上数学课。有一次上课，数学老师布置了一道题目：给出一组有规律的整数，而且只给出前5项，求出后面5项。比如：1，2，3，4，5，□，□，□，□，□。显然这是等差数列，所以答案应该是6，7，8，9，10。老师规定规律只有三种：等差数列、等比数列、斐波那契数列（f[i]=f[i-2]+f[i-1]）；且公差、公比均为整数，所有出现的数字不会超出int范围。聪明的你，来比一比你和小鹏谁算的快。"], "image_urls": [], "input": "每行5个整数，代表题目给出的前5项，用空格分隔。", "output": "如果能找到符合条件的规律，则输出5个整数，代表后5项的值。否则，请输出NULL", "sample_input": "2 3 5 8 13", "sample_output": "21 34 55 89 144"},
{"number": "088", "name": "勇闯天涯", "description": ["进行一次勇闯天涯帆船冒险活动。", "帆船可以在港口租到，并且之间没有区别。一条帆船最多只能乘坐两个人，且乘客的总重量不能超过帆船的最大承载量。我们要尽量减少这次活动中的花销，所以要找出可以安置所有旅客的最少的帆船条数。现在请写一个程序，读入帆船的最大承载量、旅客数目和每位旅客的重量。根据给出的规则，计算要安置所有旅客必须的最少的帆船条数，并输出结果。"], "image_urls": [], "input": "第1行包括两个整数w，n，80≤w≤200,1≤n≤300，w为一条帆船的最大承载量，n为人数。", "output": "每组人数所需要的最少帆船的条数。", "sample_input": "85 6\r5 84 85 80 84 83", "sample_output": "5"},
{"number": "087", "name": "不屈的小蜗", "description": ["传说中能站在金字塔顶的只有两种动物，一种是鹰，一种是蜗牛。比奇堡的小蜗听了这个传说后，大受鼓舞，立志要去爬上金字塔。为了实现自己的梦想，小蜗找到了老鹰，老鹰告诉它金字塔高H米，小蜗牛知道：白天自己能向上爬10米，但由于晚上要休息，自己会下滑5米。它想知道自己在第几天能站在金字塔顶，你帮他写个程序吧。"], "image_urls": [], "input": "输入一个整数H（0<H<1000000000）代表金字塔的高度。", "output": "输出一个整数n表示小蜗第n天站在金字塔顶上。", "sample_input": "1000", "sample_output": "199"},
{"number": "086", "name": "最长回文子串", "description": ["输入一个字符串，求其中最长回文子串。子串的含义是：在字符串中连续出现的字符串片段。回文的含义是：正着看和倒着看是相同的，如abba和abbebba。在判断时要求忽略所有的标点和空格，且忽略大小写，但输出时按原样输出（首尾不要输出多余的字符串）。输入字符串长度大于等于1小于等于5000，且单独占一行。"], "image_urls": [], "input": "输入一行字符串。", "output": "输出所要求的回文子串。", "sample_input": "Last Week,todo level odot,King", "sample_output": "k,todo level odot,K"},
{"number": "085", "name": "延伸的卡片", "description": ["你能使一叠在桌子上的卡片向外伸出多远？", "如果你有一个卡片，这张卡片最多可以向桌子外伸出卡片的一半长度（假设该卡片必须垂直于桌子），如果有两个卡片，就可以让上面的卡片向外伸出下面那张卡片的一半长度，而下面那张卡伸出桌子卡片的三分之一长度，所以两张卡片总的向外延伸1/2 + 1/3 = 5/6卡长度。以此类推，N张卡片向外延伸1/2+1/3+1/4+…+1/（n +1）卡片长度，最上面的向外延伸1/2，第二张向外延伸1/3，第三张向外延伸1/4，…，最下面一张向外延伸1 /（n +1）。如下图所示。"], "image_urls": ["poj/images/80/8000075012.jpg"], "input": "每个测试数据是一个3位正浮点数c，最小值为0.01，最大值为5.20。", "output": "输出卡片的最小数目，为整型。", "sample_input": "1.5", "sample_output": "6"},
{"number": "084", "name": "公园喷水器", "description": ["现有一块草坪，长为20米，宽为2米，要在横中心线上放置半径为Ri的喷水装置，每个喷水装置的效果都会让以它为中心的半径为实数Ri(0<Ri<15)的圆被湿润，这有充足的喷水装置i（1<i<600)个，并且一定能把草坪全部湿润，你要做的是：选择尽量少的喷水装置，把整个草坪的全部湿润。"], "image_urls": [], "input": "第1行输入一个整数n，表示共有n个喷水装置。第2行有n个实数Ri，Ri表示该喷水装置能覆盖的圆的半径。", "output": "输出所用装置的个数", "sample_input": "5\r2 3.2 4 4.5 6", "sample_output": "2"},
{"number": "083", "name": "The Ratio of gainers to losers", "description": ["If you ever see a televised report on stock market activity, you'll hear the anchorperson say something like ``Gainers outnumbered losers 14 to 9,'' which means that for every 14 stocks that increased in value that day, approximately 9 other stocks declined in value. Often, as you hear that, you'll see on the screen something like this:", "Gainers 1498", "Losers 902", "As a person with a head for numbers, you'll notice that the anchorperson could have said ``Gainers outnumbered losers 5 to 3'', which is a more accurate approximation to what really happened. After all, the exact ratio of winners to losers is (to the nearest millionth) 1.660754, and he reported a ratio of 14 to 9, which is 1.555555, for an error of 0.105199; he could have said ``5 to 3'', and introduced an error of only 1.666667-1.660754=0.005913. The estimate ``5 to 3'' is not as accurate as ``1498 to 902'' of course; evidently, another goal is to use small integers to express the ratio. So, why did the anchorperson say ``14 to 9?'' Because his algorithm is to lop off the last two digits of each number and use those as the approximate ratio.", "What the anchorman needs is a list of rational approximations of increasing accuracy, so that he can pick one to read on the air. Specifically, he needs a sequence {a_1, a_2, ..., a_n} where a_1 is a rational number with denominator 1 that most exactly matches the true ratio of winners to losers (rounding up in case of ties), a_{i+1} is the rational number with least denominator that provides a more accurate approximation than a_i, and a_n is the exact ratio, expressed with the least possible denominator. Given this sequence, the anchorperson can decide which ratio gives the best tradeoff between accuracy and simplicity.", "For example, if 5 stocks rose in price and 4 fell, the best approximation with denominator 1 is 1/1; that is, for every stock that fell, about one rose. This answer differs from the exact answer by 0.25 (1.0 vs 1.25). The best approximations with two in the denominator are 2/2 and 3/2, but neither is an improvement on the ratio 1/1, so neither would be considered. The best approximation with three in the denominator 4/3, is more accurate than any seen so far, so it is one that should be reported. Finally, of course, 5/4 is exactly the ratio, and so it is the last number reported in the sequence.", "Can you automate this process and help the anchorpeople? "], "image_urls": [], "input": "input contains one pair of positive integers. Each pair is on a line by itself, beginning in the first column and with a space between the two numbers. The first number of a pair is the number of gaining stocks for the day, and the second number is the number of losing stocks for the day. The total number of stocks never exceeds 5000. ", "output": "For each input pair, the standard output should contain a series of approximations to the ratio of gainers to losers. The first approximation has '1' as denominator, and the last is exactly the ratio of gainers to losers, expressed as a fraction with least possible denominator. The approximations in between are increasingly accurate and have increasing denominators, as described above.", "sample_input": "5 4", "sample_output": "1/1\r4/3\r5/4"},
{"number": "082", "name": "路痴", "description": ["路痴一旦不高兴，就必然一个人漫无目的的出去走走。今天被老师训了，他又不高兴了，怎么办？那就出去走呗，反正丢不了。这次幸好记下出来时的方向，并且在一张纸上密密麻麻的记下了他拐的弯（每次拐的弯都是90度的弯），0代表左拐，1代表右拐，那么多0、1，他实在看不下去了，正好遇见聪明的你，你能告诉他，他现在面向哪吗？"], "image_urls": [], "input": "第1行输入他开始时的面对方向，和他拐弯次数n（0<n<100）。", "output": "他现在所面向的方向(West、East、North、South)", "sample_input": "East 6\r0 0 0 0 0 0", "sample_output": "West"},
{"number": "081", "name": "阶乘合计", "description": ["假定一个非负数整数n，判断n是不是一些数（这些数不允许重复使用，且为正数）的阶乘之和，如9=1!+2!+3!，如果是，则输出YES，否则输出NO；"], "image_urls": [], "input": "输入一个正整数n<1000000", "output": "如果符合条件，输出YES，否则输出NO", "sample_input": "840", "sample_output": "YES"},
{"number": "080", "name": "链表节点删除", "description": ["编写程序建立一个链表，每个结点包括：学号、姓名、年龄，输入一个学号，如果链表中的结点包括该学号，则输出该结点内容后，并将其结点删去。"], "image_urls": [], "input": "连续输入学号int no、姓名char name[12]、年龄int age，结束学号输入0。再输入查找节点学号。", "output": "输出第1行为原链表，第2行为删除节点后的链表。", "sample_input": "101 zhang 18\r102 wang 21\r103 zhou 19\r104 chen 20\r105 huang 20\r0\r103", "sample_output": "101 102 103 104 105\r101 102 104 105"},
{"number": "079", "name": "火车站", "description": ["在PushPop城中有一个著名的火车站，车站铁路如图所示。", "每辆火车都从A方向驶入车站，再从B方向驶出车站，同时它的车厢可以进行某种形式的重新组合。假设从A方向驶来的火车有N节车厢（N≤1000），分别按顺序编号为1，2，…，N。负责车厢调度的工作人员需要知道能否使它以A1，A2，…，An的顺序从B方向驶出。", "请你编写程序，用来判断能否得到指定的车厢顺序。假定在进入车站之前每节车厢之间都是不连着的，并且它们可以自行移动，直到处在B方向的铁轨上。另外假定车站可以停放任意多的车厢。但是一旦车厢进入车站，它就不能再回到A方向的铁轨上了，并且一旦它驶入B方向的铁轨后，它就不能再回到车站。"], "image_urls": ["poj/images/80/8000070012.jpg"], "input": "第1行输入N，接下来的一行是任意多个的出站重组顺序（A1，A2，…，），以0为结束标志，用空格分隔。", "output": "输出Yes表示可以把火车（1，2，…，N）火车编排成所需要的顺序（A1，A2，…，），否则用No表示。", "sample_input": "5\r1 2 3 4 5 0", "sample_output": "Yes"},
{"number": "078", "name": "大数减法", "description": ["编写一个程序实现A-B，A和B两个数的位数有近100位。注意：需要处理正负数的情形，但不考虑小数。", "提示：C或C++没有直接表示100位的数据类型，我们得自己先构造一个合适的类型，接下来还需要一些巧妙的方法处理100位数的输入和输出，因为标准输入输出同样没有这样类型的处理功能。"], "image_urls": [], "input": "分别用两行输入不超过100位的A和B（没有小数点，允许正负号）。", "output": "输出A-B的结果。", "sample_input": "3333333333333333333333333333333333\r-2222222222222222222222222222222222", "sample_output": "5555555555555555555555555555555555"},
{"number": "077", "name": "排序分析", "description": ["有一个排序算法QuickSort。这个算法是将n个不同的整数由小到大进行排序，算法的操作是在需要的时候将相邻的2个数交换。例如，对于输入序列9 1 0 5 4，QuickSort产生0 1 4 5 9的结果。", "你的任务是算出QuickSort最少需要用到多少次交换操作，才能对输入的序列由小到大排序。"], "image_urls": [], "input": "第1行输入序列的个数n，第2行输入n个序列元素。", "output": "输出进行排序所做的交换操作的最少次数。", "sample_input": "5\r9 1 0 5 4", "sample_output": "6"},
{"number": "076", "name": "创建与遍历职工链表", "description": ["建立一个链表，每个结点包括的成员为：职工号。用一个creat函数来建立链表，用list函数来输出数据。"], "image_urls": [], "input": "第1行输入n，第2行输入n个职工号，用空格分隔。", "output": "从头节点开始输出每个结点职工号，用空格分隔。", "sample_input": "7\r101 102 103 104 105 106 107", "sample_output": "101 102 103 104 105 106 107"},
{"number": "075", "name": "毕业设计论文打印", "description": ["NWPU长安校区只有一个复印店，每年6月份的时候它承担了繁重的毕业设计论文打印工作。有时候在打印机队列中有上百份的论文要打印，为此，你可能要等上几个小时才能得到一份论文打印。", "因为有些打印工作比较重要，所以Ten School发明和实现了打印工作队列的一个简单优先系统。每个打印工作被赋予了一个从1到9 的优先级（9是最高优先级，1是最低优先级），打印机操作如下：", "（1）将队列中的第一个打印工作J从队列中取出；", "（2）如果在队列中有优先级高于J的打印工作，则不打印J，而是将J移到队列后端；", "（3）否则打印J（不将J移到队列后端）；", "用了这个方法，所有重要的文件能很快被打印。当然，令人烦恼的是其他要被打印的论文要等上更多的时间。", "现在，你的任务是编写程序计算你的打印工作什么时候被完成。给出当前队列和优先级列表，以及你的论文在队列中的位置，计算需要多长时间你的工作才被打印。假定队列中不会加入附加的工作，为了使事情简单化，设定一件打印工作花费1小时，向队列中添加一项打印工作和移走一件打印工作瞬间就能完成。"], "image_urls": [], "input": "第1行输入两个整数n和m，其中n是队列中的对象个数（1≤n≤100），m是你的打印工作的位置（0≤m≤n-1）。队列中第1个位置编号为0，第2个位置编号为1，以此类推。", "output": "输出一个整数，表示你的打印工作完成需要多少小时。假定打印工作进行的时候没有附加的打印加入。", "sample_input": "4 2\r1 2 3 4", "sample_output": "2"},
{"number": "074", "name": "精确乘幂", "description": ["对一个实数R（0.0＜R＜99.999），编写程序精确计算R的n次方，其中n是整数且0≤n≤25。"], "image_urls": [], "input": "输入R和n，用空格分隔。", "output": "输出R的n次方精确值，输出需要去掉无用的0。如果输出结果是整数，不要输出小数点。", "sample_input": "95.123 12", "sample_output": "548815620517731830194541.899025343415715973535967221869852721"},
{"number": "073", "name": "链表动态增长或缩小", "description": ["建立一个链表，每个结点数据包括：年龄。n次输入年龄，如果链表中的结点所包含的年龄等于此年龄，则将此结点删去。否则增加一个新结点。"], "image_urls": [], "input": "第1行输入n，第2行输入n个年龄值，用空格分隔。", "output": "输出整个链表数据，用空格分隔。", "sample_input": "10\r12 16 16 17 19 20 22 27 34 22", "sample_output": "12 17 19 20 27 34"},
{"number": "072", "name": "行程编码压缩算法", "description": ["RLE（Run Length Encoding行程编码）算法是一个简单高效的无损数据压缩算法，其基本思路是把数据看成一个线性序列，而这些数据序列组织方式分成两种情况：一种是连续的重复数据块，另一种是连续的不重复数据块。对于连续的重复数据快采用的压缩策略是用一个字节（我们称之为数据重数属性）表示数据块重复的次数，然后在这个数据重数属性字节后面存储对应的数据字节本身，例如某一个文件中有如下的数据序列AAAAA，在未压缩之前占用5个字节，而如果使用了压缩之后就变成了5A，只占用两个字节，对于连续不重复的数据序列，表示方法和连续的重复数据块序列的表示方法一样，只不过前面的数据重数属性字节的内容为1。一般的这里的数据块取一个字节，这篇文章中数据块都默认为一个字节。", "具体来讲，字符串的编码规则如下：", "在字符串中，2～9个相同的字符组成的子字符串用2个字符来编码表示。第1个字符是这一字符串的长度，为2～9。第2个字符是相同字符的值。如果一个字符串存在相同字符且多于9个的子串，就先对前9个字符进行编码，然后对其余相同字符组成的子串采用相同方法进行编码。例如AAAAAABCCCC编码为6A1B14C。", "在字符串中，如果存在某个子串，其中没有一个字符连续重复出现，就表示为以字符1开始，后面跟着这一子串，再以字符结束。如果在字符串中存在只有1个字符1出现的子串，则以两个字符1作为输出，例如12344编码为11123124。"], "image_urls": [], "input": "输入一个字符串。", "output": "输出RLE编码后的字符串。", "sample_input": "AAAAAABCCCC12344", "sample_output": "6A1B14C11123124"},
{"number": "070", "name": "子字符串替换", "description": ["编写函数void replace(char *str,char *fstr,char *rstr)，将str所指字符串中凡是与fstr字符串相同的字符替换成rstr（rstr与fstr的字符长度不一定相同）。从主函数中输入原始字符串\"iffordowhileelsewhilebreak\"、查找字符串\"while\"和替换字符串\"struct\"，调用函数得到结果。"], "image_urls": [], "input": "第1行输入要替换的字符串str，第2行输入查找字符串fstr，第3行输入替换字符串rstr。", "output": "输出替换后的字符串str。", "sample_input": "iffordowhileelsewhilebreak\rwhile\rstruct", "sample_output": "iffordostructelsestructbreak"},
{"number": "071", "name": "插入链表节点", "description": ["建立一个链表，每个结点包括的成员为：职工号。用一个creat函数来建立链表，用list函数来输出数据。现在新增加一个职工的数据，按职工号的顺序插入链表。写一函数insert来插入新结点。"], "image_urls": [], "input": "第1行输入n，第2行输入n个职工号（由小到大）用来创建链表，用空格分隔。第3行输入插入元素值。", "output": "输出插入后的链表。", "sample_input": "7\r101 102 103 104 105 107 108\r106", "sample_output": "101 102 103 104 105 106 107 108"},
{"number": "069", "name": "分数加减法", "description": ["编写一个C程序，实现两个分数的加减法。"], "image_urls": [], "input": "每行数据是一个字符串，格式是“a/b+c/d”或“a/b-c/d”。其中a, b, c, d是一个0-9的整数。b、d不为0。输入数据保证合法。", "output": "对于输入数据的每一行输出两个分数的运算结果。注意结果应符合书写习惯，没有多余的符号、分子、分母，并且化简至最简分数。例如：“1/4-1/2”的结果是-1/4，“1/3-1/3”的结果是0。", "sample_input": "1/8+3/8", "sample_output": "1/2"},
{"number": "067", "name": "源程序添加行号", "description": ["编写程序给源程序文件DATA5612.CPP加上行号后存储到另外一个文本文件DATA5612.TXT中。"], "image_urls": [], "input": "用记事本自行建立一个DATA5612.CPP文件，输入一些源程序测试，存放在与程序相同的文件夹中。", "output": "程序运行结果是产生文件，无输出显示。下面是文件测试结果：", "sample_input": null, "sample_output": null},
{"number": "068", "name": "字符串加密编码", "description": ["编写函数void strencode(char *s)；函数的功能是将字符串中的大写字母加3，小写字母减3。在主函数中输入字符串，调用函数后输出结果字符串。"], "image_urls": [], "input": "输入一行字符串。", "output": "输出编码操作后的字符串。", "sample_input": "ABCDEF", "sample_output": "DEFGHI"},
{"number": "065", "name": "文件比较", "description": ["已有两个文本文件（DATA5613.TXT和DATA5613.CPP），请编写程序从这两个文件中读出各行字符，逐个比较这两个文件中相应的行和列上的字符，如果遇到互不相同的字符，输出它是第几行第几列的字符。"], "image_urls": [], "input": "用记事本自行建立DATA5613.TXT和DATA5613.CPP文件，输入一些数据测试，存放在与程序相同的文件夹中。", "output": "输出互不相同字符的行和列值，一行一个字符，用空格分隔。", "sample_input": null, "sample_output": "1 7\r3 6\r7 9"},
{"number": "066", "name": "POJer的烦恼", "description": ["ACM队的POJer小C经常抱怨：“C语言中格式输出中有十六、十、八进制输出，却没有二进制输出，哎，谁能帮我写一个程序实现输入一个十进制数n，输出它的二进制数呀？”", "你能帮帮他吗？"], "image_urls": [], "input": "输入数据n（0≤n≤1000010000）", "output": "输出对应一个十进制数n的二进制数，注意：输出的二进制去掉任何一个多余的0。", "sample_input": "9", "sample_output": "1001"},
{"number": "064", "name": "搜索字符", "description": ["编写函数char* search(char *cpsource,char ch)，该函数在一个字符串中找到可能的最长的子字符串，该字符串是由同一字符组成的。从主函数中输入\"aabbcccddddeeeeeffffff\"和'e'，调用函数得到结果。"], "image_urls": [], "input": "第1行输入字符串，第2行输入字符ch。", "output": "输出子字符串", "sample_input": "aabbcccddddeeeeeffffff\re", "sample_output": "eeeee"},
{"number": "063", "name": "小型数据库", "description": ["编写程序完成：①输入若干学生的数据：学号(int)，姓名(char [12])，成绩(int)，并存储在文件DATA5614.DB中；②从文件中再读出学生数据，打印成绩最好的学生的相关信息。"], "image_urls": [], "input": "第1行输入学生人数n，第2行输入n个人数的学号、姓名、成绩，用空格分隔。", "output": "输出成绩最好的学生的记录，用空格分隔。", "sample_input": "5\r101 zhang 78 106 wang 88 107 chen 78 103 wang 88 104 chen 98", "sample_output": "104 chen 98"},
{"number": "062", "name": "检查图像文件格式", "description": ["互联网上最流行三种图片格式为：JPEG、GIF、PNG。这三个格式的文件，包含特殊图像数据。如果是JPEG文件，其文件偏移第6个字节处（以0起始）为JFIF；如果是GIF文件，其文件偏移第0个字节处（以0起始）为GIF89a；如果是PNG文件，其文件偏移第1个字节处（以0起始）为PNG。现在编写程序，判断一个数据文件DATA5609.DAT是什么格式？"], "image_urls": [], "input": "自行从互联网上下载一个图像文件，更名为DATA5609.DAT来测试。例如是一个JPEG文件。", "output": "根据格式分别JPEG、GIF、PNG字符串。若不是这三种格式，输出NULL", "sample_input": null, "sample_output": "JPEG"},
{"number": "061", "name": "检测位图长宽", "description": ["24位BMP位图文件DATA5611.BMP由文件头、位图信息头和图形数据三部分组成。文件头主要包含文件大小、文件类型、图像数据偏离文件头的长度等信息；位图信息头包含图像尺寸信息、图像像素字节数、是否压缩、图像所用颜色数等信息（http://www.wotsit.org/网站上有各种图形图像、音频视频、文档文件格式的说明）。根据位图文件格式定义文件头、位图信息头结构体类型，从位图文件读取结构体数据从而得到位图文件信息。编写程序求DATA5611.BMP位图的长和宽。"], "image_urls": [], "input": "用绘图工具自行创建一个20x20的DATA5611.BMP位图文件，存放在源程序在相同的文件夹中，用来测试自己的程序。", "output": "输出位图的长和宽，用空格分隔。", "sample_input": null, "sample_output": "20 20"},
{"number": "060", "name": "合并字符串", "description": ["编写一个函数void stringmerge(char S1[],char S2[])，对键盘输入的两个字符串S1和S2进行连接，结果送回到S1中。在主函数输入输出，调用这个函数合并字符串。"], "image_urls": [], "input": "用2行分别输入2个字符串。", "output": "输出为字符串。", "sample_input": "hello\rworld", "sample_output": "helloworld"},
{"number": "059", "name": "特殊要求的字符串", "description": ["编写程序对字符串按下面给定的条件进行排序，排序后的结果仍按行重新存入字符串中并打印出来。", "条件：从字符串中间一分为二，左边部分按字符的ASCII值降序排序，右边部分按字符的ASCII值升序排序；排序后，左边部分与右边部分进行交换。如果原字符串长度为奇数，则最中间的字符不参加排序，字符仍放在原位置上。"], "image_urls": [], "input": "输入一行字符串。", "output": "输出结果字符串。", "sample_input": "abcd9876", "sample_output": "6789dcba"},
{"number": "058", "name": "字符串排序", "description": ["在主函数中输入10个等长的字符串（每个字符串最多10个字符），用另一个函数对它们进行由小到大排序，然后在主函数中输出这10个已排好序的字符串。"], "image_urls": [], "input": "输入10个等长的字符串，用空格分隔。", "output": "输出排序后的10个字符串，用空格分隔。", "sample_input": "she its can ibm bbc NBA nhk BOY jxf eat", "sample_output": "BOY NBA bbc can eat ibm its jxf nhk she"},
{"number": "057", "name": "字符串左中右", "description": ["编写实现下面字符串操作要求的函数。在主函数中输入字符串\"www.nwpu.edu.cn\"，调用函数并得到结果。", "（1）函数void Left(char src[],int n,char dest[])将字符串src左边n个字符复制到dest中。", "（2）函数void Right(char src[],int n,char dest[])将字符串src右边n个字符复制到dest中。", "（3）函数void Mid(char src[],int loc,int n,char dest[])将字符串src自下标loc开始的n个字符复制到dest中。"], "image_urls": [], "input": "第1行输入字符串，第2行输入n和loc值，用空格分隔。", "output": "第1行输出调用函数Left的结果，第2行输出调用函数Right的结果，第3行输出调用函数Mid的结果", "sample_input": "www.nwpu.edu.cn\r5 5", "sample_output": "www.n\rdu.cn\rwpu.e"},
{"number": "056", "name": "删除字符", "description": ["编制函数void deletechar(char S[],char c)，其功能是删除一个字符串S中指定的字符c。要求原始字符串在主函数中输入，处理后的字符串在主函数中输出。"], "image_urls": [], "input": "第1行输入字符串", "output": "输出为字符串。", "sample_input": "Nikon: wfeel thew awir arouwnd the wuniverse\rw", "sample_output": "Nikon: feel the air around the universe"},
{"number": "055", "name": "字符串替换", "description": ["编写一个程序实现将字符串中的所有”you”替换成”we”"], "image_urls": [], "input": "输入数据是一个字符串，长度不超过1000", "output": "对于输入的每一行，输出替换后的字符串", "sample_input": "you are what you do", "sample_output": "we are what we do"},
{"number": "054", "name": "分离单词", "description": ["编写程序以字符串为单位，以空格或标点符号（字符串中仅含英文逗号','或小数点'.'作为标点符号）作为分隔符，对字符串中所有单词进行倒排，然后把已处理的字符串（应不含标点符号）打印出来。"], "image_urls": [], "input": "输入一个字符串（包含大小写字母、空格、逗号或小数点）", "output": "输出处理后的字符串。", "sample_input": "I am a student. I like study.", "sample_output": "study like I student a am I"},
{"number": "053", "name": "字符串逆序", "description": ["请编写程序，对键盘输入的字符串进行逆序，逆序后的字符串仍然保留在原来字符数组中，最后输出。（不得调用任何字符串处理函数），例如：输入 输出。"], "image_urls": [], "input": "输入字符串时，输入以等号（=）结束（注意不是回车）", "output": "输出为字符串。", "sample_input": "hello world=\rdlrow olleh", "sample_output": "dlrow olleh"},
{"number": "052", "name": "Music Composer", "description": ["Mr. B is a famous music composer. One of his most famous work was his set of preludes. These 24 pieces span the 24 musical keys (there are musically distinct 12 scale notes, and each may use major or minor tonality). The 12 distinct scale notes are:", "Five of the notes have two alternate names, as is indicated above with equals sign. Thus, there are 17 possible names of scale notes, but only 12 musically distinct notes. When using one of these as the keynote for a musical key, we can further distinguish between major and minor tonalities. This gives 34 possible keys, of which 24 are musically distinct.", "In naming his preludes, Mr. B used all the keys except the following 10, which were named instead by their alternate names:", "Write a program that, given the name of a key, give an alternate name if it has one, or report the key name is unique."], "image_urls": ["poj/images/80/8000046000a.jpg", "poj/images/80/8000046000b.jpg"], "input": "Each test case is described by one line having the format “note tonality”, where “note” is one of the 17 names for the scale notes given above, and “tonality” is either “major” or “minor” (quotes for clarify).", "output": "For each case output the required answer, following the format of the sample.", "sample_input": "Ab minor", "sample_output": "G# minor"},
{"number": "051", "name": "字符串复制", "description": ["输入任意一个字符串（包含n个字符，1≤n≤100），编写函数，将此字符串中从第m个字符开始（以0起始）的全部字符复制成为另一个字符串并输出（m＜n）。"], "image_urls": [], "input": "第1行输入字符串，第2行输入整数m。", "output": "输出为字符串。", "sample_input": "112233445566778899\r7", "sample_output": "45566778899"},
{"number": "050", "name": "右上角", "description": ["输出一个NxN（1≤N≤100）二维数组A右上角的元素（元素值不超过9）。"], "image_urls": [], "input": "第1行输入整型n，第2行给A输入nxn个整型数据，元素之间用空格隔开。", "output": "按要求输出A左上角的元素，确保行列对齐，元素之间用空格隔开。", "sample_input": "3\r1 2 3 4 5 6 7 8 9", "sample_output": "1 2 3\r  5 6\r    9"},
{"number": "049", "name": "平均值函数", "description": ["编写一个函数double avg(int A[],int s,int e)，计算一个N（1≤N≤100）个元素的一维数组A，从第s个（以0为开始，下同），到第e个元素的平均值，其中0≤s＜e＜N。在主函数输入输出，调用函数avg计算。"], "image_urls": [], "input": "第1行输入整型n，第2行给A输入n个整型数据，第3行输入s和e，数据之间用空格隔开。", "output": "输入double型，默认小数位。", "sample_input": "10\r1 2 3 4 5 6 7 8 9 10\r1 8", "sample_output": "5.500000"},
{"number": "048", "name": "一维数组“赋值”", "description": ["有两个N（1≤N≤100）个元素的数组A和B，其中A来自输入，将其“赋值”给B（即元素一一复制到B中），输出B数组下标为奇数的元素。"], "image_urls": [], "input": "第1行输入整型n，第2行给A输入n个整型数据，元素之间用空格隔开。", "output": "输出B数组指定元素，元素之间用空格隔开。", "sample_input": "5\r1 2 3 4 5", "sample_output": "2 4"},
{"number": "047", "name": "边沿与内芯的差", "description": ["计算一个NxM（1≤N、M≤100）二维数组A所有边沿元素的和s1，所有内芯元素的和s2，输出s1-s2。"], "image_urls": [], "input": "第1行输入整型n和m，接下来输入n行，每行m个元素给A，数据之间用空格隔开。", "output": "输出s1-s2为整型。", "sample_input": "3 4\r1 1 1 1\r1 2 2 1\r1 1 1 1", "sample_output": "6"},
{"number": "046", "name": "右下角", "description": ["输出一个NxN（1≤N≤100）二维数组A右下角的元素（元素值不超过9）。"], "image_urls": [], "input": "第1行输入整型n，第2行给A输入nxn个整型数据，元素之间用空格隔开。", "output": "按要求输出A左上角的元素，确保行列对齐，元素之间用空格隔开。", "sample_input": "3\r1 2 3 4 5 6 7 8 9", "sample_output": "    3\r  5 6\r7 8 9"},
{"number": "045", "name": "冒泡排序", "description": ["编写一个函数void BubbleSort(int A[],int s,int m)，能够从数组A第s个（以0为开始）元素起始，连续m个元素使用冒泡法降序排序。数组A最多有N（1≤N≤100）个元素，0≤s＜N，且s+m≤N。在主函数输入输出，调用函数BubbleSort求解。"], "image_urls": [], "input": "第1行输入整型n，第2行给A输入n个整型数据，第3行输入s和m，数据之间用空格隔开。", "output": "输出排序后的数组A，用空格隔开。", "sample_input": "10\r1 2 3 4 5 6 7 8 9 10\r1 8", "sample_output": "1 9 8 7 6 5 4 3 2 10"},
{"number": "044", "name": "左下角", "description": ["输出一个NxN（1≤N≤100）二维数组A左下角的元素（元素值不超过9）。"], "image_urls": [], "input": "第1行输入整型n，第2行给A输入nxn个整型数据，元素之间用空格隔开。", "output": "按要求输出A左上角的元素，确保行列对齐，元素之间用空格隔开。", "sample_input": "3\r1 2 3 4 5 6 7 8 9", "sample_output": "1\r4 5\r7 8 9"},
{"number": "043", "name": "选择排序", "description": ["编写一个函数void SelectionSort(int A[],int s,int m)，能够从数组A第s个（以0为开始）元素起始，连续m个元素使用选择法降序排序。数组A最多有N（1≤N≤100）个元素，0≤s＜N，且s+m≤N。在主函数输入输出，调用函数SelectionSort求解。"], "image_urls": [], "input": "第1行输入整型n，第2行给A输入n个整型数据，第3行输入s和m，数据之间用空格隔开。", "output": "输出排序后的数组A，用空格隔开。", "sample_input": "10\r1 2 3 4 5 6 7 8 9 10\r1 8", "sample_output": "1 9 8 7 6 5 4 3 2 10"},
{"number": "042", "name": "山迪的麻烦", "description": ["山迪要出席一个周末表演晚会，他在会上要表演卡片魔术。他有n（0＜n≤100）张卡片，每张卡片上都标明了1～1000之间的某个数字，这n张卡片本来是有序的，可是山迪的助手不小心把卡片打乱了。这可急坏了山迪，忙令助手迅速通过一些操作把这些卡片变回有序的，而山迪的助手是个思想简单的人，他能做的操作只有一种：交换任意两张卡片的位置。", "现在，山迪想知道助手最少交换几次可以达到目的，以便尽快决定是否替换这个魔术表演，聪明的你能帮助他么？"], "image_urls": [], "input": "第1行是一个正整数n，第2行n个是打乱顺序后、每张卡片上的数字。", "output": "输出所需要的最少交换次数", "sample_input": "5\r1 4 7 8 3", "sample_output": "3"},
{"number": "041", "name": "快速排序", "description": ["编写一个函数void QuickSort(int A[100],int s,int m)，能够从数组A第s个（以0为开始）元素起始，至第m个元素结束使用快速排序降序排序。数组A最多有N（1≤N≤100）个元素，0≤s＜N，且s+m≤N。在主函数输入输出，调用函数QuickSort求解。"], "image_urls": [], "input": "第1行输入整型n，第2行给A输入n个整型数据，第3行输入s和m，数据之间用空格隔开。", "output": "输出排序后的数组A，用空格隔开。", "sample_input": "10\r1 2 3 4 5 6 7 8 9 10\r1 8", "sample_output": "1 9 8 7 6 5 4 3 2 10"},
{"number": "040", "name": "亲和数", "description": ["古希腊数学家毕达哥拉斯在自然数研究中发现，220的所有真约数（即不是自身的约数）之和为：", "1+2+4+5+10+11+20+22+44+55+110＝284", "而284的所有真约数为", "1+2+4+71+ 142", "加起来恰好为220。人们对这样的数感到很惊奇，称之为亲和数。一般地讲，如果两个数中任何一个数都是另一个数的真约数之和，则这两个数就是亲和数。现在，编写一个程序，判断给定的两个数是否是亲和数。"], "image_urls": [], "input": "输入数据包含两个整数A、B，其中 0≤A，B≤600000", "output": "如果A和B是亲和数的话输出YES，否则输出NO。", "sample_input": "220 284", "sample_output": "YES"},
{"number": "039", "name": "不会吧，又是A+B", "description": ["A+B是POJer的最爱。这不，今天这个A+B希望能给大家带来好运，也希望这个题目能唤起大家对ACM的热爱。", "这个题目的A和B不是简单的整数，而是两个时间，A和B 都是由3个整数组成，分别表示时、分、秒。比如，假设A为34 45 56，就表示A所表示的时间是34小时45分钟56秒。"], "image_urls": [], "input": "输入数据每行有6个整数AH、AM、AS、BH、BM、BS，分别表示时间A和B所对应的时分秒。题目保证所有的数据合法。", "output": "输出A+B，每个输出结果也是由时分秒3部分组成，同时也要满足时间的规则（即分和秒的取值范围在0~59），每个输出占一行，并且所有的部分都可以用32位整数表示。", "sample_input": "1 2 3 4 5 6", "sample_output": "5 7 9"},
{"number": "038", "name": "数据加密", "description": ["某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的。加密函数如下：每位数字都加上5，然后用除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。"], "image_urls": [], "input": "输入整型", "output": "输出整型", "sample_input": "1998", "sample_output": "3446"},
{"number": "037", "name": "最大整数", "description": ["编写函数getfloor(x)，返回小于等于x的最大整数，例如getfloor(2.8)为2，getfloor(-2.8)为-3。"], "image_urls": [], "input": "输入double型x。", "output": "输出整型。", "sample_input": "2.8", "sample_output": "2"},
{"number": "036", "name": "高低交换", "description": ["编写内联函数inline int xchg(unsigned char n)，计算将unsigned char型n的低四位和高四位交换后的结果。在主函数中输入数据调用函数输出结果。"], "image_urls": [], "input": "输入整型", "output": "输出整型", "sample_input": "194", "sample_output": "44"},
{"number": "020", "name": "计算π", "description": ["编写程序利用下面公式计算π的近似值："], "image_urls": ["poj/images/80/8000022008.jpg"], "input": null, "output": "输出π为实型，保留六位小数。", "sample_input": null, "sample_output": "3.141591"},
{"number": "019", "name": "二分求根", "description": ["请编写程序，用二分法求下面方程在(－10，10)之间的根："], "image_urls": ["poj/images/80/8000022002.jpg"], "input": "输入区间数据为实型、用空格隔开输出均。", "output": "输出根为实型，保留两位小数。", "sample_input": "-10 10", "sample_output": "2.00"},
{"number": "018", "name": "你会存钱吗？", "description": ["假设银行整存整取存款不同期限的月息利率分别为：", "利息=本金*月息利率*12*存款年限。", "现在某人手中有2000元钱，请通过计算选择一种存钱方案，使得钱存入银行20年后得到的利息最多（假定银行对超过存款期限的那一部分时间不付利息）。"], "image_urls": ["poj/images/80/8000022006.jpg"], "input": null, "output": "输出第1行为8年、5年、3年、2年、1年的存款方案（各利率存款次数），用空格隔开。输出第2行为最大收益。", "sample_input": null, "sample_output": "0 4 0 0 0\r8841.01"},
{"number": "017", "name": "VOL大学乒乓球比赛", "description": ["VOL大学有两个乒乓球队进行比赛，各出3人。甲队为A、B、C三人，乙队为X、Y、Z三人，已抽签决定比赛名单，有人向队员打听比赛的名单，A说他不和X比，C说他不和X、Z比，请编写程序找出3对赛手的名单。"], "image_urls": [], "input": null, "output": "输出赛手名单，一行一对。", "sample_input": null, "sample_output": "A=Z\rB=X\rC=Y"},
{"number": "016", "name": "奇特的分数数列", "description": ["有一个分数数列：", "求出这个数列前20项之和。"], "image_urls": ["poj/images/80/8000022005.jpg"], "input": null, "output": "输出保留六位小数。", "sample_input": null, "sample_output": "32.660261"},
{"number": "015", "name": "最次方数", "description": ["编写程序求一个整数的任意次方的最后三位数。即："], "image_urls": ["poj/images/80/8000022012.jpg"], "input": "输入均为整型，首先为x，其后为a，用空格隔开。", "output": "输出为整型。", "sample_input": "13 13", "sample_output": "253"},
{"number": "014", "name": "五猴分桃", "description": ["5只猴子一起摘了1堆桃子。因为太累了，它们商量决定，先睡一觉再分。过了不知多久，1只猴子来了。它见别的猴子没来，便将这1堆桃子平均分成5份，结果多了1个，就将多的这个吃了，拿走其中的1堆。又过了不知多久，第2只猴子来了。它不知道有1个同伴已经来过，还以为自己是第1个到的呢。于是将地上的桃子堆起来，平均分成5份，发现也多了1个，同样吃了这1个，拿走其中的1堆。第3只、第4只、第5只猴子都是这样……问这5只猴子至少摘了多少个桃子？第5个猴子走后还剩下多少个桃子？"], "image_urls": [], "input": null, "output": "输出5只猴子至少摘了多少个桃子，第5个猴子走后还剩下多少个桃子。中间用空格隔开。", "sample_input": null, "sample_output": "3121 1020"},
{"number": "013", "name": "两个整数之间所有的素数", "description": ["编写程序，求任意两个整数之间所有的素数。"], "image_urls": [], "input": "输入两个整数，用空格间隔。注意输入的两个整数谁大谁小是任意的。", "output": "输出数据占一行，用空格间隔。", "sample_input": "100 130", "sample_output": "101 103 107 109 113 127"},
{"number": "012", "name": "级数和", "description": ["编写程序求下面级数前n项的和，其中n从键盘上输入。"], "image_urls": ["poj/images/80/8000022009.jpg"], "input": "输入n为整型。", "output": "输出和为实型，保留六位小数。", "sample_input": "5", "sample_output": "0.338462"},
{"number": "011", "name": "完全数", "description": ["一个数如果恰好等于它的因子之和，这个数就称为\"完数\"。例如，6的因子为1、2、3，而6=1+2+3，因此6是\"完数\"。请编写程序，找出1000之内的所有完数。"], "image_urls": [], "input": null, "output": "每行按格式输出其因子：6=1+2+3", "sample_input": null, "sample_output": "6=1+2+3\r28=1+2+4+7+14\r496=1+2+4+8+16+31+62+124+248"},
{"number": "010", "name": "求建筑高度", "description": ["有4个圆塔，圆心分别为(2，2)、(-2，2)、(2，-2)、(-2，-2)，圆半径为1。这4个塔的高度为10m。塔以外无建筑物。请编写程序，输入任一点的坐标，求该点的建筑高度(塔外的高度为零)。"], "image_urls": ["poj/images/80/8000010009.jpg"], "input": "输入为实型，以”,”隔开", "output": "输出为整型", "sample_input": "2,2.5", "sample_output": "10"},
{"number": "009", "name": "成绩转换", "description": ["百分制成绩转换为五分制成绩，转换规则为：90～100：A；80～89：B；70～79：C；60～69：D；60分以下：E。输入百分制成绩，输出对应的五分制成绩。"], "image_urls": [], "input": "输入为整型", "output": "输出为字符型", "sample_input": "87", "sample_output": "B"},
{"number": "008", "name": "是该年的第几天？", "description": ["输入一个日期(YYYY-MM-DD)输入一个日期，判断是这一年的第几天？"], "image_urls": [], "input": "输入为整型，以”-”隔开", "output": "输出为整型", "sample_input": "2013-6-17", "sample_output": "168"},
{"number": "006", "name": "奖金发放", "description": ["企业发放的奖金根据利润提成。利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润I，求应发放奖金总数？"], "image_urls": [], "input": "输入为实型(单位为万元)", "output": "输出为实型，保留六位小数(单位为万元)", "sample_input": "35", "sample_output": "2.500000"},
{"number": "007", "name": "出租车费", "description": ["西安出租车的收费标准：起步价（2公里以内，含2公里）为7元钱，超过2公里且在15公里以内（含15公里）时每公里收费1.5元，超过15公里时每公里收费2.1元，不足1公里按照1公里收费。"], "image_urls": [], "input": "输入为实型(单位为公里)", "output": "输出为实型，保留六位小数(单位为元)", "sample_input": "9.2", "sample_output": "19.000000"},
{"number": "005", "name": "找幸运数", "description": ["如果一个整数逆序后得到的数值和原数值相同，则称之为幸运数。输入一个整数N（N＜100000）判断是否为幸运数，是的话输出”yes”，否则输出”no”。"], "image_urls": [], "input": "输入一个整数", "output": "输出为字符串", "sample_input": "1234", "sample_output": "no"},
{"number": "004", "name": "找最大数", "description": ["找出三个数据A，B，C中的最大数"], "image_urls": [], "input": "输入为整型，用空格分隔", "output": "输出为整型", "sample_input": "100 29 712", "sample_output": "712"},
{"number": "003", "name": "计算成绩", "description": ["输入某学生的数学、英语和C语言课程成绩，输出该学生三门课总成绩和平均成绩"], "image_urls": [], "input": "输入为实型，用空格分隔", "output": "输出为实型，保留六位小数，结果每行输出一个", "sample_input": "90 82 74", "sample_output": "246.000000\r82.000000"},
{"number": "002", "name": "圆及圆球等的相关计算", "description": ["输入圆半径r和圆柱高h，计算圆周长l、圆面积s、圆球表面积sq、圆球体积vq和圆柱体积vz"], "image_urls": [], "input": "输入实型，用空格分隔", "output": "按顺序输出圆周长、圆面积、圆球表面积、圆球体积、圆柱体积，保留2位小数，结果每行输出一个", "sample_input": "1.5 3", "sample_output": "9.42\r7.07\r28.27\r14.14\r21.21"}
]